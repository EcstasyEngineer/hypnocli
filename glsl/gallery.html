<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GLSL Seed & Top-Rated Gallery</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #111; color: #ddd; font-family: monospace; }
  #header { padding: 10px 20px; background: #1a1a2e; border-bottom: 1px solid #333; display: flex; align-items: center; gap: 20px; }
  #header h1 { font-size: 16px; color: #8af; }
  #nav { display: flex; gap: 6px; flex-wrap: wrap; }
  .nav-btn { padding: 4px 10px; border: 1px solid #444; background: #222; color: #aaa; cursor: pointer; font-family: monospace; font-size: 11px; border-radius: 3px; }
  .nav-btn:hover { background: #333; color: #fff; }
  .nav-btn.active { background: #336; color: #8cf; border-color: #68f; }
  .nav-btn.seed { border-left: 3px solid #6a4; }
  .nav-btn.rated { border-left: 3px solid #a64; }
  #viewer { display: flex; flex-direction: column; align-items: center; padding: 20px; }
  #info { margin-bottom: 10px; font-size: 13px; color: #888; }
  canvas { border: 1px solid #333; }
  #shader-src { margin-top: 15px; width: 90%%; max-width: 800px; }
  #shader-src pre { background: #1a1a1a; padding: 12px; border-radius: 4px; font-size: 11px; overflow-x: auto; max-height: 400px; overflow-y: auto; color: #ccc; border: 1px solid #333; }
  #controls { margin-top: 10px; display: flex; gap: 10px; align-items: center; }
  .ctrl-btn { padding: 6px 16px; border: 1px solid #444; background: #222; color: #ccc; cursor: pointer; font-family: monospace; border-radius: 3px; }
  .ctrl-btn:hover { background: #333; }
  #error { color: #f66; margin-top: 10px; font-size: 12px; }
</style>
</head>
<body>
<div id="header">
  <h1>GLSL Gallery (v2 seeds + 7+ rated)</h1>
  <div id="nav"></div>
</div>
<div id="viewer">
  <div id="info"></div>
  <canvas id="c" width="640" height="640"></canvas>
  <div id="controls">
    <button class="ctrl-btn" onclick="prev()">&#9664; Prev</button>
    <button class="ctrl-btn" onclick="next()">Next &#9654;</button>
  </div>
  <div id="error"></div>
  <div id="shader-src"><pre id="src-code"></pre></div>
</div>
<script>
const SHADERS = [
  ["seed:convergent_spiral", `// convergent_spiral.glsl
// Archetype: convergent
// Core motivation: Create an inescapable pull toward the center. Radial inversion makes
//   the viewer's gaze feel physically drawn inward, while logarithmic spiral arms create
//   self-similar depth that suggests infinite recession. Decoupled speeds between angle
//   and radius prevent the eye from locking onto any single feature.
// atan note: avoids atan entirely — uses Chebyshev T4 on rotated direction vector for
//   seam-free angular pattern (safest approach for any arm count).
// Known issues: at very high arm counts (>8) aliasing near origin. Keep arm_count <= 6.

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);

    // Radial inversion: sqrt pulls outer ring into center
    float r = length(uv);
    float r_inv = 1.0 / (r + 0.01);  // inversion_sqrt: compressed outer radius

    // Seam-free angular pattern: use sin/cos on the unit direction directly.
    // This avoids the atan() branch cut at ±π entirely.
    float log_r = log(r + 0.001);
    vec2 dir = uv / (r + 1e-6);
    float arms = 4.0;  // arm_count
    float spiral_wind = log_r * 1.5 + iTime * 0.4;  // spiral_offset + log_shear

    // Rotate direction by spiral_wind, then use Chebyshev T₄ for 4 arms
    float cw = cos(spiral_wind), sw = sin(spiral_wind);
    vec2 rot = vec2(dir.x * cw - dir.y * sw, dir.x * sw + dir.y * cw);
    // cos(4θ) = 8cos⁴θ - 8cos²θ + 1  (Chebyshev T₄)
    float c2 = rot.x * rot.x;
    float c4 = 8.0 * c2 * c2 - 8.0 * c2 + 1.0;

    // Angular pattern with decoupled time speeds
    float angle_wave = c4 * 0.5 + 0.5;
    float depth_wave = sin(log_r * 8.0 - iTime * 1.2) * 0.5 + 0.5;  // decoupled_speeds

    // Compose
    float v = mix(angle_wave, depth_wave, 0.4) * (1.0 - smoothstep(0.0, 1.5, r_inv * r));
    float glow = exp(-r * 3.0) * 0.5;  // center glow for convergence pull

    vec3 col = vec3(
        v * 0.3 + glow,
        v * 0.6 * abs(sin(iTime * 0.3)),
        v * 0.9 + glow * 0.5
    );

    fragColor = vec4(col, 1.0);
}
`],
  ["seed:double_arm", `// double_arm.glsl
// Archetype: linear_rings
// Core motivation: Create a beating interference pattern that bypasses voluntary attention.
//   Two counter-rotating arm sets produce a moire that oscillates at the difference
//   frequency — the viewer can't track either arm independently, forcing the visual system
//   into a global "defocused" state. Color channels on offset clocks add chromatic drift.
// atan note: uses atan() safely — sin(2*theta + ...) masks the branch cut (integer N in sin).
// Known issues: arm_count > 2 makes the beat too fast to be hypnotic.

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);

    // Two counter-rotating arms
    float arm1 = sin(theta * 2.0 + r * 10.0 - iTime * 1.5);
    float arm2 = sin(theta * 2.0 - r * 10.0 + iTime * 1.1);  // inversion_linear via sign flip
    float beat = arm1 * arm2;  // interference

    // abs_fold: fold negative values into positive — creates ripple from 0
    float folded = abs(beat);

    // triangle_wave via abs(fract - 0.5) for rings
    float rings = abs(fract(r * 6.0 - iTime * 0.3) - 0.5) * 2.0;  // triangle_wave

    float v = mix(folded, rings, 0.3);

    // channel_time_offset: R, G, B on different clocks
    float r_val = abs(sin(theta * 2.0 + r * 10.0 - iTime * 1.5 + 0.0));
    float g_val = abs(sin(theta * 2.0 + r * 10.0 - iTime * 1.5 + 1.0));
    float b_val = abs(sin(theta * 2.0 + r * 10.0 - iTime * 1.5 + 2.0));

    vec3 col = vec3(
        v * r_val,
        v * g_val * 0.8,
        v * b_val * 1.2
    );

    fragColor = vec4(col, 1.0);
}
`],
  ["seed:flow_field", `// flow_field.glsl
// Archetype: flow_field
// Core motivation: Simulate a fluid field with visible sources and sinks. Rings expand
//   from sources and contract into sinks, creating multiple competing focal points that
//   prevent the viewer from settling on any one spot. The slow drift of poles ensures the
//   pattern never repeats exactly, preventing adaptation.
// Known issues: singularities near poles cycle very fast (feature, not bug).

#define TAU 6.28318530

vec3 hsv(float h, float s, float v) {
    vec3 c = clamp(abs(mod(h*6.0+vec3(0,4,2),6.0)-3.0)-1.0, 0.0, 1.0);
    return v * mix(vec3(1.0), c, s);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5*iResolution.xy) / min(iResolution.x, iResolution.y);

    float t = iTime * 0.10;

    // 3 sources — slowly drift
    vec2 src[3];
    src[0] = vec2( 0.50 + 0.04*sin(t*0.7),   0.12 + 0.05*cos(t*0.9));
    src[1] = vec2(-0.38 + 0.05*cos(t*0.8),   0.42 + 0.04*sin(t*0.6));
    src[2] = vec2( 0.04 + 0.04*sin(t*1.1),  -0.48 + 0.04*cos(t*0.75));

    // 3 sinks
    vec2 snk[3];
    snk[0] = vec2(-0.48 + 0.04*cos(t*0.65), -0.18 + 0.05*sin(t*0.85));
    snk[1] = vec2( 0.28 + 0.05*sin(t*0.95), -0.33 + 0.04*cos(t*0.7));
    snk[2] = vec2(-0.08 + 0.04*cos(t*0.8),   0.50 + 0.04*sin(t*1.0));

    // Velocity potential: Φ = Σ log(r_source) - Σ log(r_sink)
    // Near a source: Φ → -∞, rings expand outward as time increases
    // Near a sink:   Φ → +∞, rings contract inward as time increases
    float phi = 0.0;
    for (int i = 0; i < 3; i++) {
        phi += log(max(length(uv - src[i]), 0.001));
        phi -= log(max(length(uv - snk[i]), 0.001));
    }

    // Animate: slower drift
    float phase = phi - iTime * 0.35;

    // Posterized rainbow: flat bands with quick soft transitions at edges
    float hue_raw = fract(phase * 0.25);
    float steps = 7.0;
    float cell = hue_raw * steps;
    float hue = (floor(cell) + smoothstep(0.0, 0.35, fract(cell))) / steps;

    vec3 col = hsv(hue, 1.0, 0.9);

    fragColor = vec4(col, 1.0);
}
`],
  ["seed:fract_zoom", `// fract_zoom.glsl
// Archetype: fractal_zoom (alternative to Mandelbrot)
// Core motivation: Exploit fract() recursion to create infinite self-similar nesting.
//   Each iteration rescales and recenters UV, so the structure repeats at every scale.
//   The length(uv)*exp(-length(uv0)) term pulls brightness inward — inner regions glow
//   while outer rings recede, creating convergent attention pull. IQ cosine palette
//   shifts per iteration for color-coded depth layers.
// Source: Kishimisu (https://www.shadertoy.com/view/mtyGWy)
// Known issues: none — no atan(), all motion continuous, no branch cuts.

//https://iquilezles.org/articles/palettes/
vec3 palette( float t ) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.263,0.416,0.557);

    return a + b*cos( 6.28318*(c*t+d) );
}

//https://www.shadertoy.com/view/mtyGWy
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;
    vec2 uv0 = uv;
    vec3 finalColor = vec3(0.0);

    for (float i = 0.0; i < 4.0; i++) {
        uv = fract(uv * 1.5) - 0.5;

        float d = length(uv) * exp(-length(uv0));

        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);

        d = sin(d*8. + iTime)/8.;
        d = abs(d);

        d = pow(0.01 / d, 1.2);

        finalColor += col * d;
    }

    fragColor = vec4(finalColor, 1.0);
}
`],
  ["seed:galaxy", `// galaxy.glsl
// Archetype: log_arms
// Core motivation: Mimic natural galaxy morphology to exploit pre-wired depth-from-motion
//   circuits. The human visual system parses spiral arm structure as depth cues — three
//   log-spiral arms with warm-core IQ palette create an immediate sense of gazing into
//   deep space. The sqrt falloff gives smooth brightness that pulls gaze toward the core.
// atan note: avoids atan entirely — uses Chebyshev T3 on rotated direction vector for
//   seam-free angular pattern.

vec3 iq_palette(float t) {
    // iq_cosine_palette: a + b * cos(2π(c*t + d))
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);

    // log_shear: logarithmic radial coordinate for spiral arms
    float log_r = log(r + 0.1) * 0.5;

    // Seam-free angular pattern: use sin/cos directly instead of atan().
    // For N arms, compute sin(N * angle + spiral_offset) via trig identity
    // on the unit direction vector, avoiding the ±π branch cut entirely.
    vec2 dir = uv / (r + 1e-6);
    float arms = 3.0;
    float spiral_wind = log_r * 2.0 - iTime * 0.25;
    // Chebyshev expansion: cos(3θ + φ) from cos(θ), sin(θ)
    // Use complex-number multiplication to rotate by spiral_wind first
    float cw = cos(spiral_wind), sw = sin(spiral_wind);
    vec2 rotated = vec2(dir.x * cw - dir.y * sw, dir.x * sw + dir.y * cw);
    // cos(3θ) = 4cos³θ - 3cosθ  (Chebyshev T₃)
    float c3 = 4.0 * rotated.x * rotated.x * rotated.x - 3.0 * rotated.x;

    // Arm brightness: smooth cosine wave pinched by r falloff
    float arm_bright = c3 * 0.5 + 0.5;
    float falloff = exp(-r * 1.8);  // sqrt_gamma-like smooth falloff

    float v = arm_bright * falloff + falloff * 0.15;  // arms + core glow

    // iq_cosine_palette: use smooth phase from log_r for color (also seam-free)
    float color_phase = log_r * 0.3 + iTime * 0.05;
    vec3 col = iq_palette(color_phase) * v;
    col += vec3(1.0, 0.9, 0.7) * falloff * 0.3;  // warm core

    fragColor = vec4(col, 1.0);
}
`],
  ["seed:kaleidoscope", `// kaleidoscope.glsl
// Archetype: kaleidoscopic
// Core motivation: N-fold mirror symmetry eliminates asymmetric distractors. The viewer
//   can't track any single element — attention diffuses to the global gestalt. Slow rotation
//   at decoupled speeds (inner vs outer) creates vortex pull. The interplay between angular
//   sectors and radial rings produces visual tension that prevents adaptation.
// atan note: uses atan() safely — mod(theta, sector) + fold masks the +/-pi branch cut.
// Known issues: folds < 4 look too simple; folds > 12 may stall GPU on old hardware.

#define PI 3.14159265

vec3 iq_palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 0.5);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);

    // arm_count: N-fold symmetry via abs_fold on theta
    float N = 6.0;
    float sector = 2.0 * PI / N;
    // abs_fold: fold into [0, sector/2]
    float t_folded = mod(theta, sector);
    if (t_folded > sector * 0.5) t_folded = sector - t_folded;

    // Reconstruct UV in folded sector
    vec2 uv_fold = r * vec2(cos(t_folded), sin(t_folded));

    // Inner domain: slow rotate; outer: faster rotate (decoupled_speeds)
    float inner_speed = 0.2;
    float outer_speed = 0.5;
    float rot_angle = mix(inner_speed, outer_speed, smoothstep(0.2, 0.8, r)) * iTime;

    // spiral_offset in folded domain
    float spiral = sin(t_folded * N * 2.0 + log(r + 0.1) * 3.0 + rot_angle) * 0.5 + 0.5;

    // Radial rings
    float rings = abs(fract(r * 5.0 - iTime * 0.15) - 0.5) * 2.0;

    float v = mix(spiral, rings, 0.4);

    // sqrt_gamma: soften the contrast
    v = sqrt(max(v, 0.0));

    // Rich IQ palette — phase varies with angle and radius for multi-hue spread
    float hue_phase = t_folded * 2.0 + r * 0.8 + rot_angle * 0.3;
    vec3 col = iq_palette(hue_phase) * (v * 0.7 + 0.3);

    // Center glow for convergence pull
    col += vec3(0.15, 0.1, 0.25) * exp(-r * 3.0);

    fragColor = vec4(col, 1.0);
}
`],
  ["seed:sdf_spiral", `// sdf_spiral.glsl
// Archetype: sdf_outline
// Core motivation: Two counter-rotating spiral sets create glowing isoline intersections
//   that pulse rhythmically. Each intersection is a "wave" of brightness — the pulsing
//   catches attention without any net directional drift. The SDF glow at each isoline
//   simulates depth layering.
// atan note: uses atan() safely — fract(theta/(2pi)*arms) for integer arms masks the
//   branch cut. The integer jump at +/-pi disappears under fract().
// Known issues: glow radius depends on screen resolution — use iResolution-normalized distances.

float sdSpiral(vec2 p, float arms, float tightness, float t) {
    float r = length(p);
    float theta = atan(p.y, p.x);
    float log_r = log(r + 0.001);

    // Distance to nearest spiral arm isoline
    float phase = (theta / (2.0 * 3.14159) * arms + log_r * tightness - t);
    float dist = abs(fract(phase + 0.5) - 0.5) / arms;

    return dist * r;  // scale by radius for perspective-like falloff
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);

    // Counter-rotating spirals: eliminates directional flow,
    // creates pulsing intersection nodes where arms cross
    float d1 = sdSpiral(uv, 4.0, 1.8,  iTime * 0.3);
    float d2 = sdSpiral(uv, 4.0, 1.8, -iTime * 0.3);
    float d = min(d1, d2);

    // glow_inversion: bright at d=0, dark at d=large
    float glow = exp(-d * 30.0);
    float outline = smoothstep(0.015, 0.01, d);

    // pow_contrast: enhance glow falloff
    float v = pow(glow + outline * 0.5, 0.6);

    // Color tied to radius only — no time drift
    float r = length(uv);
    float hue_shift = log(r + 0.1) * 0.5;

    vec3 col = vec3(
        v * (0.6 + 0.4 * sin(hue_shift)),
        v * (0.6 + 0.4 * sin(hue_shift + 2.094)),
        v * (0.6 + 0.4 * sin(hue_shift + 4.189))
    );

    fragColor = vec4(col, 1.0);
}
`],
  ["rated:fdcb3101(linear_rings)", `// shader_id: fdcb31019c25
// archetype: linear_rings
// techniques: inversion_linear, log_shear, arm_count, spiral_offset, abs_fold, decoupled_speeds
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);

    // Log radius for scale invariance
    float logr = log(r + 1.0) * 0.5;

    // Arm count = 4 for rich beat pattern
    float arm_count = 4.0;
    float tightness = 2.5;

    // Spiral offset: adds logarithmic winding
    float spiral_offset = logr * tightness;

    // Inversion_linear: counter-rotating arms with negated phase
    // Arm 1: positive rotation
    float phase1 = theta * arm_count + spiral_offset + iTime * 1.3;
    float arm1 = sin(phase1);

    // Arm 2: negative rotation (inverted) for interference
    float phase2 = -theta * arm_count - spiral_offset + iTime * 0.9;
    float arm2 = sin(phase2);

    // Beat pattern from interference
    float beat = arm1 * arm2;

    // abs_fold: fold into positive symmetric ripple
    float folded = abs(beat);

    // Linear rings with triangle wave
    float rings = abs(fract(r * 8.0 - iTime * 0.25) - 0.5) * 2.0;

    // Combine with smooth crossfade
    float pattern = mix(folded * rings, rings, 0.4);

    // Decoupled channel speeds: separate time multipliers for R, G, B
    // Prevents temporal adaptation and visual fatigue
    float time_r = iTime * 1.0;
    float time_g = iTime * 1.3;
    float time_b = iTime * 1.7;

    // Smooth continuous color gradients - no hard discontinuities
    float color_r = 0.5 + 0.5 * sin(phase1 + time_r * 0.4 + logr * 1.2);
    float color_g = 0.5 + 0.5 * sin(phase2 + time_g * 0.3 - logr * 0.9);
    float color_b = 0.5 + 0.5 * cos(theta + spiral_offset + time_b * 0.2);

    // Glow halos at structure edges via smoothstep
    float glow = smoothstep(0.1, 0.0, abs(folded - 0.5));

    // Depth illusion: multiplicative falloff with log radius
    float depth = 1.0 / (1.0 + logr * logr * 0.5);

    // Convergent motion: pull toward center via radial modulation
    float convergence = (1.0 - smoothstep(0.0, 2.0, r)) * pattern;

    // Smooth color blending without discontinuity
    vec3 col = vec3(
        (color_r * pattern + glow * 0.5) * depth,
        (color_g * pattern + glow * 0.3) * depth * 0.95,
        (color_b * pattern + glow * 0.4) * depth * 1.05
    );

    // Add subtle convergence pull
    col += vec3(convergence * 0.2, convergence * 0.15, convergence * 0.25);

    // Smooth contrast boost without banding
    col = mix(col, col * col * 3.0, 0.3);

    fragColor = vec4(col, 1.0);
}`],
  ["rated:7b2084c0(kaleidoscopic)", `// shader_id: 7b2084c033da
// archetype: kaleidoscopic
// techniques: inversion_linear, spiral_offset, arm_count, glow_inversion, decoupled_speeds, fbm_single, fbm_triple_warp
#define PI 3.14159265359
#define SQRT2 1.41421356237

uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

// FBM with 6 octaves
float fbm(vec2 p) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for(int i = 0; i < 6; i++) {
        value += amplitude * sin(p.x * frequency + iTime * 0.1) * cos(p.y * frequency + iTime * 0.07);
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
        p *= 2.0;
    }
    return value / maxValue;
}

// Triple domain warp: fbm(p + fbm(p + fbm(p)))
float fbmWarp(vec2 p) {
    vec2 p1 = p + fbm(p) * 0.3;
    vec2 p2 = p1 + fbm(p1) * 0.3;
    return fbm(p2 + fbm(p2 + vec2(iTime * 0.05)) * 0.2);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // arm_count = 5 for pentagonal kaleidoscope
    float N = 5.0;
    float sector = 2.0 * PI / N;
    
    // abs_fold: mirror symmetry into sector
    float t_folded = mod(theta, sector);
    if (t_folded > sector * 0.5) {
        t_folded = sector - t_folded;
    }
    
    // inversion_linear: counter-rotating phase via negated offset
    float inverted_phase = -t_folded;
    
    // spiral_offset: logarithmic spiral via log(r)
    float tightness = 2.5;
    float spiral_phase = log(max(r, 0.01)) * tightness;
    
    // decoupled_speeds for inner and outer regions
    float inner_time = iTime * 0.25;
    float mid_time = iTime * 0.38;
    float outer_time = iTime * 0.61;
    
    float depth_blend = smoothstep(0.1, 0.9, r);
    float speed_mod = mix(inner_time, outer_time, depth_blend);
    
    // Combined phase for spiral arms
    float phase = t_folded * N * 1.8 + spiral_phase + speed_mod + inverted_phase * 0.5;
    float phase2 = t_folded * N * 2.3 + spiral_phase * 0.7 + mid_time + inverted_phase * 0.3;
    
    // fbm_single: base noise layer
    float noise1 = fbm(uv * 2.0 + vec2(iTime * 0.1, iTime * 0.07));
    
    // fbm_triple_warp: organic warped flow
    float noise2 = fbmWarp(uv * 3.0);
    
    // Spiral arm pattern
    float spiral = sin(phase) * 0.5 + 0.5;
    spiral *= cos(phase2 * 0.5) * 0.5 + 0.5;
    
    // Radial rings with counter-rotation
    float ringPattern = abs(fract(r * 8.0 - iTime * 0.2) - 0.5) * 2.0;
    ringPattern = pow(ringPattern, 0.8);
    
    // Angular grating in folded space
    float angularGrate = abs(sin(t_folded * 12.0 + spiral_phase * 0.5 + mid_time)) * 0.7;
    
    // Distance field for glow_inversion effect
    float dist = abs(sin(phase) * r);
    float sharpness = 4.0;
    float glow = exp(-dist * sharpness) * 0.8;
    
    // Combine patterns with FBM modulation
    float pattern1 = spiral * ringPattern * (noise1 * 0.5 + 0.5);
    float pattern2 = angularGrate * (noise2 * 0.3 + 0.7);
    float combined = mix(pattern1, pattern2, 0.5) + glow;
    
    // Smooth gamma compression for depth illusion
    combined = sqrt(combined);
    combined = pow(combined, 0.85);
    
    // decoupled_speeds for color channels
    float colR = 0.5 + 0.5 * sin(speed_mod * 1.0 + phase);
    float colG = 0.5 + 0.5 * sin(speed_mod * 1.3 + phase + 2.094);
    float colB = 0.5 + 0.5 * sin(speed_mod * 1.7 + phase + 4.189);
    
    // Color gradient with radial falloff
    vec3 col = vec3(colR, colG, colB) * combined;
    
    // Add subtle iridescence from noise modulation
    col += vec3(
        noise1 * 0.15,
        noise2 * 0.12,
        mix(noise1, noise2, 0.5) * 0.1
    );
    
    // Depth vignette: pull attention inward
    float vignette = 1.0 - smoothstep(0.3, 1.2, r) * 0.4;
    col *= vignette;
    
    // Ensure smooth color transitions
    col = mix(col, vec3(0.1), smoothstep(1.0, 1.5, r));
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:2b506964(sdf_outline)", `// shader_id: 2b5069643e86
// archetype: sdf_outline
// techniques: inversion_linear, log_shear, spiral_offset, pow_contrast, decoupled_speeds, fbm_single, fbm_triple_warp
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

// FBM helper
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    
    float ab = mix(a, b, f.x);
    float cd = mix(c, d, f.x);
    return mix(ab, cd, f.y);
}

float fbm(vec2 p) {
    float v = 0.0;
    float amp = 1.0;
    float freq = 1.0;
    for(int i = 0; i < 6; i++) {
        v += noise(p * freq) * amp;
        amp *= 0.5;
        freq *= 2.0;
    }
    return v;
}

float sdSpiral(vec2 p, float arms, float tightness, float t) {
    float r = length(p);
    if(r < 0.001) r = 0.001;
    
    float theta = atan(p.y, p.x);
    float log_r = log(r);
    
    float phase = (theta / 6.28318 * arms + log_r * tightness - t);
    float dist = abs(fract(phase + 0.5) - 0.5) / arms;
    
    return dist * r;
}

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    // Linear inversion phase offset
    float invPhase = -iTime * 0.15;
    vec2 uvInv = uv * cos(invPhase * 0.3) - vec2(uv.y, -uv.x) * sin(invPhase * 0.3);
    
    // Log shear: use log(r) as coordinate
    float r = length(uv);
    if(r < 0.001) r = 0.001;
    float log_r = log(r);
    
    // Decoupled time speeds
    float t1 = iTime * 0.3;
    float t2 = iTime * 0.39;
    float t3 = iTime * 0.51;
    
    // Spiral offset with log shear
    float spiral1 = sdSpiral(uv, 5.0, 2.2 + log_r * 0.3, t1);
    float spiral2 = sdSpiral(uvInv, 3.0, 1.8 - log_r * 0.2, t2);
    
    // FBM domain warp (triple warp principle)
    vec2 p = uv * 3.0;
    float fbm1 = fbm(p);
    vec2 warped1 = p + fbm1 * 0.4;
    float fbm2 = fbm(warped1 + fbm(warped1) * 0.3);
    vec2 warped2 = warped1 + fbm2 * 0.4;
    float fbm3 = fbm(warped2 + log_r * 2.0);
    
    // Combine spirals and FBM
    float d = min(spiral1 * 0.8, spiral2 * 0.9) * (0.7 + fbm3 * 0.3);
    
    // Glow with inversion principle
    float glow = exp(-d * 25.0);
    float outline = smoothstep(0.02, 0.008, d);
    
    // Pow contrast: k varies between 0.6 and 1.2 over time
    float k = 0.8 + 0.4 * sin(iTime * 0.2);
    float v = pow(glow * 0.8 + outline * 0.6, k);
    
    // Log shear color cycling
    float baseHue = log_r * 0.15 + iTime * 0.08;
    float hue1 = mod(baseHue + fbm1 * 0.2, 1.0);
    float hue2 = mod(baseHue * 1.3 + fbm2 * 0.15 + t2 * 0.05, 1.0);
    
    // Decoupled channel saturation
    vec3 col1 = hsv2rgb(vec3(hue1, 0.7 + 0.2 * sin(t1), v * 0.9));
    vec3 col2 = hsv2rgb(vec3(hue2, 0.65 + 0.25 * sin(t3), v * 0.85));
    
    // Blend with depth layering
    vec3 finalCol = mix(col1, col2, 0.5 + 0.5 * sin(iTime * 0.25));
    
    // Additional radial glow for depth illusion
    float depthGlow = exp(-length(uv) * 1.5) * 0.3;
    finalCol += depthGlow * vec3(0.2, 0.15, 0.3);
    
    // Subtle rotation of the entire pattern
    float rotAngle = iTime * 0.05;
    vec2 rotUV = vec2(
        uv.x * cos(rotAngle) - uv.y * sin(rotAngle),
        uv.x * sin(rotAngle) + uv.y * cos(rotAngle)
    );
    float spiralRot = sdSpiral(rotUV, 4.0, 1.5, iTime * 0.25);
    float glowRot = exp(-spiralRot * 20.0);
    
    finalCol += glowRot * vec3(0.1, 0.12, 0.15) * pow(v, 0.5);
    
    // Smooth falloff at edges for vignette
    float vignette = smoothstep(2.5, 0.5, length(uv));
    finalCol *= vignette;
    
    fragColor = vec4(finalCol, 1.0);
}`],
  ["rated:c50b3bb6(linear_rings)", `// shader_id: c50b3bb6f8a1
// archetype: linear_rings
// techniques: inversion_linear, log_shear, spiral_offset, arm_count, abs_fold, decoupled_speeds, fbm_triple_warp
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

// Inigo Quilez's hash
float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

// Perlin-like noise
float noise(float x) {
    float i = floor(x);
    float f = fract(x);
    float u = f * f * (3.0 - 2.0 * f);
    return mix(hash(i), hash(i + 1.0), u);
}

// FBM with triple warp
float fbm_warped(vec2 p, float time_offset) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    
    for (int i = 0; i < 6; i++) {
        value += amplitude * noise(p.x * frequency + time_offset + float(i) * 0.1);
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    
    return value;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // [log_shear]: Use log(r) for logarithmic spiral self-similarity
    float log_r = log(r + 1.0);
    
    // [arm_count]: Set to 4 for counter-rotating spiral arms
    float arm_count = 4.0;
    
    // [spiral_offset]: Add log_r * tightness to angular phase for logarithmic spiral
    float tightness = 3.5;
    float spiral_phase = theta * arm_count + log_r * tightness;
    
    // [inversion_linear]: Counter-rotating arms via negated phase offset
    float time_factor = iTime * 0.8;
    
    // Primary spiral arm
    float arm1 = sin(spiral_phase - time_factor);
    
    // Counter-rotating arm (inverted phase)
    float arm2 = sin(-spiral_phase + time_factor * 0.6);
    
    // Additional spiral at different rotation
    float arm3 = sin(spiral_phase * 0.7 + time_factor * 1.3);
    
    // [decoupled_speeds]: Different time multipliers for depth
    float radial_modulation = sin(r * 8.0 - time_factor * 1.7) * cos(theta + time_factor * 0.9);
    
    // Combine arms with beat interference
    float beat = arm1 * arm2 + arm3 * 0.5;
    
    // [abs_fold]: Fold negative halves into positive for symmetric ripples
    float folded_beat = abs(beat);
    
    // Ring pattern with triangle wave
    float ring_freq = 6.0 + sin(time_factor * 0.4) * 2.0;
    float rings = abs(fract(r * ring_freq - time_factor * 0.5) - 0.5) * 2.0;
    
    // Exponential zoom-in effect (avoid negative zoom)
    float zoom = exp(-time_factor * 0.15 + 2.0);
    float zoom_effect = sin(log_r * 5.0 * zoom - time_factor);
    
    // [fbm_triple_warp]: Organic non-repeating warping
    vec2 warp_coord = vec2(theta, log_r);
    float warp1 = fbm_warped(warp_coord * 2.0, time_factor * 0.7);
    float warp2 = fbm_warped(warp_coord + warp1 * 0.5, time_factor * 1.1);
    float warp3 = fbm_warped(warp_coord + warp2 * 0.3, time_factor * 0.5);
    
    // Composite warp pattern
    float organic_flow = warp1 * 0.4 + warp2 * 0.35 + warp3 * 0.25;
    
    // Combine all patterns
    float pattern = mix(folded_beat, rings, 0.4);
    pattern = mix(pattern, zoom_effect, 0.25);
    pattern += organic_flow * 0.3;
    
    // [decoupled_speeds]: Color channels on different time multipliers
    float time_r = iTime * 1.0;
    float time_g = iTime * 1.3;
    float time_b = iTime * 1.7;
    
    // Channel-specific oscillations
    float r_oscillation = abs(sin(spiral_phase + time_r * 2.1 + radial_modulation));
    float g_oscillation = abs(sin(spiral_phase * 1.2 + time_g * 1.8 + organic_flow));
    float b_oscillation = abs(sin(spiral_phase * 0.8 + time_b * 2.4 - radial_modulation));
    
    // Depth color coding based on log_r
    vec3 depth_color = mix(
        vec3(0.2, 0.1, 0.4),
        vec3(0.9, 0.3, 0.6),
        smoothstep(0.0, 3.0, log_r)
    );
    
    // Final color composition
    vec3 col = vec3(
        pattern * r_oscillation * depth_color.r,
        pattern * g_oscillation * depth_color.g,
        pattern * b_oscillation * depth_color.b
    );
    
    // Glow effect at structure edges
    float edge_glow = smoothstep(0.05, 0.0, abs(folded_beat - 0.5)) * 0.6;
    float ring_glow = smoothstep(0.1, 0.0, abs(rings - 1.0)) * 0.4;
    
    col += vec3(edge_glow * 0.8, edge_glow * 0.5, edge_glow) * 0.7;
    col += vec3(ring_glow * 0.3, ring_glow * 0.6, ring_glow * 0.9) * 0.5;
    
    // Smooth fade to prevent harsh boundaries
    float fade = smoothstep(2.5, 0.0, r);
    col *= fade;
    
    // Vignette for convergent attention
    float vignette = 1.0 - smoothstep(0.0, 2.0, r) * 0.3;
    col *= vignette;
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:2a039498(sdf_outline)", `// shader_id: 2a039498ee3e
// archetype: sdf_outline
// techniques: log_shear, spiral_offset, abs_fold, decoupled_speeds
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

float sdSpiral(vec2 p, float arms, float tightness, float t) {
    float r = length(p);
    if(r < 0.001) r = 0.001;
    float theta = atan(p.y, p.x);
    float logr = log(r);

    float phase = (theta / 6.28318 * arms + logr * tightness - t);
    float dist = abs(fract(phase + 0.5) - 0.5) * 6.28318 / arms;

    return dist * r;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);

    float t1 = iTime * 0.3;
    float t2 = iTime * 0.39;
    float t3 = iTime * 0.51;

    float r = length(uv);
    float logr = log(r + 0.1);
    float theta = atan(uv.y, uv.x);

    float d1 = sdSpiral(uv, 4.0, 1.8, t1);
    float d2 = sdSpiral(uv, 3.0, 1.5, t2);
    float d3 = sdSpiral(uv, 5.0, 2.1, t3);

    float combined = min(min(d1, d2), d3 * 1.2);

    float glow1 = exp(-d1 * 25.0);
    float glow2 = exp(-d2 * 30.0);
    float glow3 = exp(-d3 * 20.0);

    float outline1 = smoothstep(0.025, 0.008, d1);
    float outline2 = smoothstep(0.02, 0.006, d2);
    float outline3 = smoothstep(0.03, 0.01, d3);

    // sdSpiral returns dist*r, which trivially -> 0 at origin; fade out the artifact
    float center_fade = smoothstep(0.0, 0.1, r);
    glow1 *= center_fade;
    glow2 *= center_fade;
    glow3 *= center_fade;
    outline1 *= center_fade;
    outline2 *= center_fade;
    outline3 *= center_fade;

    float ripple = abs(sin(logr * 3.0 + t1 * 2.0));
    ripple = abs(ripple - 0.5) * 2.0;
    ripple *= exp(-length(uv) * 0.5);

    float hue1 = logr * 0.4 + t1 * 0.2;
    float hue2 = logr * 0.35 + t2 * 0.15;
    float hue3 = logr * 0.45 + t3 * 0.1;

    vec3 col1 = vec3(
        0.5 + 0.5 * sin(hue1),
        0.5 + 0.5 * sin(hue1 + 2.094),
        0.5 + 0.5 * sin(hue1 + 4.189)
    );

    vec3 col2 = vec3(
        0.6 + 0.4 * sin(hue2 + 1.047),
        0.6 + 0.4 * sin(hue2 + 3.142),
        0.6 + 0.4 * sin(hue2 + 5.236)
    );

    vec3 col3 = vec3(
        0.55 + 0.45 * sin(hue3 + 3.0),
        0.55 + 0.45 * sin(hue3 + 1.5),
        0.55 + 0.45 * sin(hue3 + 0.5)
    );

    float v1 = pow(glow1 + outline1 * 0.6, 0.65);
    float v2 = pow(glow2 + outline2 * 0.5, 0.7);
    float v3 = pow(glow3 + outline3 * 0.4, 0.6);

    vec3 final = col1 * v1 * 0.7 + col2 * v2 * 0.6 + col3 * v3 * 0.5;
    final += vec3(ripple * 0.3);

    float depth = exp(-length(uv) * 1.5);
    final *= (0.7 + 0.3 * depth);

    // Saturation push
    float luma = dot(final, vec3(0.299, 0.587, 0.114));
    final = mix(vec3(luma), final, 1.25);
    final = max(final, 0.0);

    final = pow(final, vec3(0.95));

    fragColor = vec4(final, 1.0);
}`],
  ["rated:ff1c204f(linear_rings)", `// shader_id: ff1c204f56a1
// archetype: linear_rings
// techniques: inversion_linear, log_shear, spiral_offset, arm_count, abs_fold, triangle_wave, decoupled_speeds, fbm_triple_warp
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

// Simplex-like noise for organic motion
float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

// Multi-octave FBM with domain warping
float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    for(int i = 0; i < 8; i++) {
        v += a * noise(p);
        p = p * 2.0 + vec2(0.1, 0.2);
        a *= 0.5;
    }
    return v;
}

// Triple domain warp FBM for organic flow
float fbmWarp(vec2 p) {
    float f1 = fbm(p);
    float f2 = fbm(p + vec2(f1 * 0.4));
    return fbm(p + vec2(f2 * 0.4));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Normalized coordinates with center at origin
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);

    // Radial coordinates
    float r = length(uv);
    float theta = atan(uv.y, uv.x);

    // Logarithmic spiral coordinate for self-similar depth
    float logR = log(r + 1.5);

    // arm_count: 4 spiral arms for complex interference
    float armCount = 4.0;

    // Spiral offset: log(r) * tightness creates logarithmic spiral effect
    float spiralTightness = 2.5;
    float spiralPhase = logR * spiralTightness;

    // Time multipliers for decoupled_speeds (prevent temporal adaptation)
    float t1 = iTime * 0.8;
    float t2 = iTime * 1.3;
    float t3 = iTime * 1.7;

    // Counter-rotating spiral arms (inversion_linear via negated phase)
    float arm1 = sin(theta * armCount + spiralPhase - t1);
    float arm2 = sin(theta * armCount - spiralPhase + t2);  // inverted phase for counter-rotation

    // Beat interference pattern from counter-rotation
    float beat = arm1 * arm2;

    // abs_fold: fold negative values to create symmetric ripple
    float folded = abs(beat);

    // Triangle wave rings (abs(fract - 0.5) * 2) for smooth ring patterns
    float rings = abs(fract(r * 8.0 - t1 * 0.5) - 0.5) * 2.0;

    // Additional triangle wave for secondary ripple
    float rings2 = abs(fract(logR * 6.0 + t2 * 0.3) - 0.5) * 2.0;

    // fbm_triple_warp for organic non-repeating flow — pulsing intensity
    vec2 warpPos = vec2(r * cos(theta), r * sin(theta));
    float warp = fbmWarp(warpPos + vec2(iTime * 0.3));
    float warpPulse = 0.5 + 0.5 * sin(iTime * 0.7);  // pulse the noise contribution
    warp *= warpPulse;

    // Combine patterns with varying blend factors
    float pattern = folded * 0.5 + rings * 0.3 + rings2 * 0.2;
    pattern = mix(pattern, warp * 0.7, 0.4);

    // Glow/halo effect at structure edges for depth illusion
    float edgeGlow = exp(-abs(fract(r * 4.0 - t1 * 0.2) - 0.5) * 8.0) * 0.8;

    // Smooth depth gradient creating convergence toward center
    float depthFade = 1.0 - smoothstep(0.0, 3.0, r);
    float convergence = sin(theta * 3.0 + logR * 1.5 - t3 * 0.6) * 0.3 + 0.7;

    // Channel time offsets for chromatic drift (decoupled_speeds) — wider phase spread for saturation
    float r_val = abs(sin(theta * armCount + spiralPhase - t1 * 1.0 + 0.0));
    float g_val = abs(sin(theta * armCount + spiralPhase - t1 * 1.3 + 2.5));
    float b_val = abs(sin(theta * armCount + spiralPhase - t1 * 1.7 + 5.0));

    // Color with glow and convergence — boosted channel separation
    vec3 col = vec3(
        (pattern + edgeGlow) * r_val * convergence * 1.2,
        (pattern * 0.7 + edgeGlow * 0.5) * g_val * convergence * 0.85,
        (pattern * 0.5 + edgeGlow * 0.9) * b_val * convergence * 1.3
    );

    // Pulsing warp-based color modulation
    col += vec3(
        warp * 0.35 * sin(t1),
        warp * 0.2 * sin(t2 + 2.0),
        warp * 0.3 * sin(t3 + 4.0)
    );

    // Apply depth fade for infinite recession illusion
    col *= depthFade;

    // Saturate: push channels apart from their average
    float luma = dot(col, vec3(0.299, 0.587, 0.114));
    col = mix(vec3(luma), col, 1.6);

    // Smooth color gradients to avoid banding
    col = max(col, 0.0);
    col = mix(col, col * col, 0.15);

    // Final smoothness and tonality
    col = pow(col, vec3(0.85));

    fragColor = vec4(col, 1.0);
}`],
  ["rated:7cf547c0(linear_rings)", `// shader_id: 7cf547c0a3a8
// archetype: linear_rings
// techniques: log_shear, inversion_linear, spiral_offset, arm_count, abs_fold, triangle_wave, iq_cosine_palette, channel_time_offset, fbm_triple_warp
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // log_shear: logarithmic radial coordinate for self-similarity
    float logr = log(r + 1.5);
    
    // spiral_offset: wind arms into logarithmic spiral
    float tightness = 2.8;
    float spiral_phase = logr * tightness;
    
    // arm_count: 4 arms for balanced hypnotic pattern
    float arm_count = 4.0;
    float arm_phase = theta * arm_count;
    
    // inversion_linear: counter-rotating arms via negated phase offset
    float arm1_phase = arm_phase + spiral_phase - iTime * 1.2;
    float arm2_phase = arm_phase - spiral_phase + iTime * 0.9;
    
    // oscillating arm strength with depth modulation
    float arm1 = sin(arm1_phase) * (0.5 + 0.5 * sin(iTime * 0.7));
    float arm2 = sin(arm2_phase) * (0.5 + 0.5 * cos(iTime * 0.5));
    
    // abs_fold: fold negative values to create symmetric ripple
    float interference = abs(arm1 * arm2);
    float arm_strength = abs(arm1) + abs(arm2);
    
    // triangle_wave: smooth ring pattern using abs(fract(x) - 0.5) * 2
    float ring_radii = r * 8.0 - iTime * 0.4;
    float rings = abs(fract(ring_radii) - 0.5) * 2.0;
    rings = mix(rings, 1.0 - rings, 0.5);
    
    // fbm_triple_warp: organic non-repeating flow
    // Simplified warp using layered sine waves for compile-time safety
    float warp1 = sin(logr * 3.5 + iTime * 0.3) * 0.4;
    float warp2 = sin(theta * 5.0 - iTime * 0.5) * 0.3;
    float warp3 = sin((logr + warp1) * 2.0 + iTime * 0.2) * 0.2;
    
    float warped_r = r + warp1 + warp2 * 0.1;
    float warped_theta = theta + warp3;
    
    // Recalculate with warped coordinates for organic flow
    float organic_base = sin(warped_theta * 6.0 + warped_r * 5.0 - iTime * 0.8);
    organic_base = abs(organic_base);
    
    // Combine patterns with depth perception
    float depth_layer = exp(-r * 1.5) * 0.7;
    float mid_layer = interference * rings * (0.5 + 0.5 * sin(iTime * 0.4));
    float surface = arm_strength * organic_base * (1.0 - r * 0.4);
    
    float pattern = mix(mid_layer, surface, 0.6) + depth_layer * 0.4;
    pattern = smoothstep(0.0, 1.0, pattern);
    
    // channel_time_offset: RGB on different phase clocks for chromatic drift
    // Offset each by 2π/3 (approximately 2.09)
    float phase_r = iTime * 0.6 + 0.0;
    float phase_g = iTime * 0.6 + 2.09;
    float phase_b = iTime * 0.6 + 4.19;
    
    // iq_cosine_palette: Inigo Quilez smooth perceptually uniform colors
    vec3 palette_a = vec3(0.5, 0.5, 0.5);
    vec3 palette_b = vec3(0.5, 0.5, 0.5);
    vec3 palette_c = vec3(1.0, 1.0, 1.0);
    vec3 palette_d = vec3(0.0, 0.33, 0.67);
    
    vec3 col_r = palette_a + palette_b * cos(6.28318 * (palette_c * sin(phase_r) * 0.5 + palette_d));
    vec3 col_g = palette_a + palette_b * cos(6.28318 * (palette_c * sin(phase_g) * 0.5 + palette_d + 0.33));
    vec3 col_b = palette_a + palette_b * cos(6.28318 * (palette_c * sin(phase_b) * 0.5 + palette_d + 0.67));
    
    float contrast = 1.8;
    float r_channel = pow(col_r.r, 2.2) * pattern * contrast;
    float g_channel = pow(col_g.g, 2.2) * pattern * contrast * 0.9;
    float b_channel = pow(col_b.b, 2.2) * pattern * contrast * 1.1;
    
    // Add glow halos at structure edges
    float edge_glow = smoothstep(0.8, 0.1, abs(fract(ring_radii) - 0.5)) * 0.4;
    r_channel += edge_glow * col_r.r;
    g_channel += edge_glow * col_g.g;
    b_channel += edge_glow * col_b.b;
    
    // Vignette and radial falloff for convergent motion
    float vignette = smoothstep(2.0, 0.3, r);
    
    vec3 col = vec3(r_channel, g_channel, b_channel) * vignette;
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:895e3a40(linear_rings)", `// shader_id: 895e3a4075ed
// archetype: linear_rings
// techniques: log_shear, arm_count, abs_fold, decoupled_speeds, fbm_triple_warp
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

float hash(float n) {
    return fract(sin(n) * 43758.5453);
}

float noise(float x) {
    float i = floor(x);
    float f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    return mix(hash(i), hash(i + 1.0), f);
}

float fbm(vec2 p) {
    float v = 0.0;
    float amp = 1.0;
    float freq = 1.0;
    for(int i = 0; i < 5; i++) {
        v += amp * noise(p.x * freq + p.y * freq * 0.5);
        amp *= 0.5;
        freq *= 2.0;
    }
    return v;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // log_shear: use log(r+small) for logarithmic self-similarity
    float logr = log(r + 0.1);
    
    // arm_count = 5 for multi-armed spiral
    int arm_count = 5;
    float arm_phase = theta * float(arm_count);
    
    // decoupled_speeds for R, G, B channels
    float t_r = iTime * 1.0;
    float t_g = iTime * 1.3;
    float t_b = iTime * 1.7;
    
    // Counter-rotating arms with log spiral
    float spiral1 = sin(arm_phase + logr * 3.0 - t_r * 2.0);
    float spiral2 = sin(arm_phase - logr * 2.5 + t_g * 1.8);
    
    // Interference/beat pattern
    float beat = spiral1 * spiral2;
    
    // abs_fold: fold negative values creating symmetric ripples
    float folded = abs(beat);
    
    // Triangle wave rings with log coordinate
    float rings = abs(fract(logr * 4.0 + r * 2.0 - t_r * 0.5) - 0.5) * 2.0;
    
    // fbm_triple_warp: triple domain warp
    vec2 p = vec2(theta, logr);
    vec2 q = p + vec2(fbm(p), fbm(p + 1.0));
    vec2 r_warp = p + 4.0 * vec2(fbm(q), fbm(q + 2.0));
    float organic = fbm(r_warp);
    
    // Convergent motion toward center
    float convergence = 1.0 / (0.1 + r * 0.5);
    
    // Combine patterns
    float pattern = mix(folded, rings, 0.4) + organic * 0.2;
    pattern = abs(sin(pattern + iTime * 0.3));
    
    // Glow halo effect at edges
    float glow = exp(-r * 1.5) * 0.5;
    
    // Decoupled color channels with slight asymmetry
    float r_chan = abs(sin(arm_phase + logr * 3.0 - t_r * 2.0 + 0.5));
    float g_chan = abs(sin(arm_phase - logr * 2.5 + t_g * 1.8 + 1.2));
    float b_chan = abs(sin(arm_phase + logr * 2.0 - t_b * 1.5 + 2.1));
    
    // Smooth color gradient with convergence
    vec3 col = vec3(
        (pattern * 0.7 + folded * 0.3) * r_chan * (0.5 + convergence * 0.3) + glow,
        (pattern * 0.6 + rings * 0.4) * g_chan * (0.4 + convergence * 0.2) + glow * 0.7,
        (pattern * 0.8 + organic * 0.2) * b_chan * (0.6 + convergence * 0.25) + glow * 0.9
    );
    
    // Depth illusion via exponential zoom
    float zoom = exp(-iTime * 0.15) * 0.3 + 0.7;
    col *= zoom;
    
    // Prevent hard edges, add smooth falloff
    col *= smoothstep(1.2, 0.3, r);
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:728549fb(convergent)", `// shader_id: 728549fb0cea
// archetype: convergent
// colorization: posterized_rainbow
// techniques: inversion_sqrt, arm_count, spiral_offset
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

vec3 hsv2rgb(vec3 hsv) {
    vec3 rgb;
    float h = hsv.x * 6.0;
    float i = floor(h);
    float f = h - i;
    float p = hsv.z * (1.0 - hsv.y);
    float q = hsv.z * (1.0 - hsv.y * f);
    float t = hsv.z * (1.0 - hsv.y * (1.0 - f));
    
    if (i < 1.0) rgb = vec3(hsv.z, t, p);
    else if (i < 2.0) rgb = vec3(q, hsv.z, p);
    else if (i < 3.0) rgb = vec3(p, hsv.z, t);
    else if (i < 4.0) rgb = vec3(p, q, hsv.z);
    else if (i < 5.0) rgb = vec3(t, p, hsv.z);
    else rgb = vec3(hsv.z, p, q);
    
    return rgb;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float r_inv = 1.0 / (r + 0.01);
    
    float theta = atan(uv.y, uv.x);
    float log_r = log(r + 0.001);
    
    float arm_count = 4.0;
    float tightness = 2.0;
    
    float t1 = iTime * 0.4;
    float t2 = iTime * 0.52;
    float t3 = iTime * 0.68;
    
    float spiral_phase = theta / (2.0 * 3.14159) * arm_count + log_r * tightness + t1;
    
    float angle_component = sin(spiral_phase * 6.28318) * 0.5 + 0.5;
    float radial_component = sin(log_r * 8.0 - t2 * 1.2) * 0.5 + 0.5;
    float modulation = cos(r * 5.0 + t3 * 0.9) * 0.5 + 0.5;
    
    float field_value = (angle_component * 0.5 + radial_component * 0.3 + modulation * 0.2);
    
    float glow = exp(-r * 3.0) * 0.8;
    float convergence_pull = smoothstep(2.0, 0.0, r_inv * 0.15);
    
    float field_with_glow = field_value + glow * 0.4 + convergence_pull * 0.3;
    
    float scale = 3.5;
    float hue_raw = fract(field_with_glow * scale);
    float steps = 7.0;
    float cell = hue_raw * steps;
    float hue = (floor(cell) + smoothstep(0.0, 0.35, fract(cell))) / steps;
    
    vec3 col = hsv2rgb(vec3(hue, 1.0, 0.9));
    
    float depth_darkening = smoothstep(3.0, 0.0, r);
    col *= (0.3 + depth_darkening * 0.7);
    
    float vignette = smoothstep(2.5, 0.5, r);
    col *= vignette;
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:be3df88a(convergent)", `// shader_id: be3df88a8199
// archetype: convergent
// colorization: posterized_rainbow
// techniques: inversion_linear, inversion_sqrt, spiral_offset, sdf_analytic
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // inversion_sqrt: compress outer distance toward center
    float r_inv = 1.0 / (r + 0.01);
    
    // spiral_offset: logarithmic spiral arms
    float log_r = log(r + 0.001);
    float arm_count = 5.0;
    float tightness = 2.2;
    float spiral_phase = theta / 6.28318 * arm_count + log_r * tightness + iTime * 0.35;
    
    // decoupled_speeds: multiple time scales prevent adaptation
    float time_1 = iTime * 1.0;
    float time_2 = iTime * 1.3;
    float time_3 = iTime * 1.7;
    
    // sdf_analytic: signed distance to spiral arm
    float wave1 = sin(spiral_phase * 6.28318);
    float wave2 = sin(spiral_phase * 6.28318 + time_2 * 0.5);
    float field_base = mix(wave1, wave2, 0.5) * 0.5 + 0.5;
    
    // Radial depth modulation: creates 3D recession illusion
    float depth_scale = 1.0 / (1.0 + r * 2.0);
    float radial_wave = sin(log_r * 5.0 + time_1 * 0.8) * 0.5 + 0.5;
    float radial_wave2 = sin(log_r * 7.0 + time_3 * 0.6) * 0.5 + 0.5;
    
    // Convergent glow: pulls attention to center
    float convergence_glow = exp(-r * 3.5) * (1.0 + 0.5 * sin(time_1 * 2.0));
    
    // Compose field value for colorization
    float field_value = field_base * 0.4 + radial_wave * 0.3 + radial_wave2 * 0.3;
    field_value = mix(field_value, convergence_glow, smoothstep(0.0, 0.3, 1.0 - r));
    
    // Spiral arm glow: creates sharp bright ridges
    float arm_sharpness = 4.0;
    float arm_glow = exp(-abs(wave1) * arm_sharpness) * 0.6;
    field_value += arm_glow * 0.4;
    
    // posterized_rainbow colorization (EXACTLY as specified)
    float hue_raw = fract(field_value * 3.5);
    float steps = 7.0;
    float cell = hue_raw * steps;
    float hue = (floor(cell) + smoothstep(0.0, 0.35, fract(cell))) / steps;
    
    // hsv to rgb conversion
    vec3 col = vec3(0.0);
    float h = hue * 6.0;
    float x = (1.0 - abs(mod(h, 2.0) - 1.0));
    
    if (h < 1.0) col = vec3(1.0, x, 0.0);
    else if (h < 2.0) col = vec3(x, 1.0, 0.0);
    else if (h < 3.0) col = vec3(0.0, 1.0, x);
    else if (h < 4.0) col = vec3(0.0, x, 1.0);
    else if (h < 5.0) col = vec3(x, 0.0, 1.0);
    else col = vec3(1.0, 0.0, x);
    
    col *= 0.9;  // posterized_rainbow: full saturation, V=0.9
    
    // Extra depth via brightness modulation
    float brightness_mod = 0.7 + 0.3 * sin(iTime * 0.4 + theta * 3.0);
    col *= brightness_mod;
    
    // Center convergence brightening
    col += convergence_glow * vec3(0.2, 0.1, 0.3) * 0.8;
    
    // Smooth out near-center to prevent singularities
    col *= smoothstep(0.0, 0.05, r);
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:7820b120(convergent)", `// shader_id: 7820b1207770
// archetype: convergent
// colorization: posterized_rainbow
// techniques: inversion_linear, spiral_offset, sdf_analytic
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

vec3 hsv(float h, float s, float v) {
    float c = v * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = v - c;
    vec3 rgb = vec3(0.0);
    
    if (h < 1.0/6.0) rgb = vec3(c, x, 0.0);
    else if (h < 2.0/6.0) rgb = vec3(x, c, 0.0);
    else if (h < 3.0/6.0) rgb = vec3(0.0, c, x);
    else if (h < 4.0/6.0) rgb = vec3(0.0, x, c);
    else if (h < 5.0/6.0) rgb = vec3(x, 0.0, c);
    else rgb = vec3(c, 0.0, x);
    
    return rgb + m;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    // Layer 1: GEOMETRY
    // Radial inversion with linear negation for counter-rotating symmetry
    float r = length(uv);
    float r_safe = max(r, 0.005);
    
    // inversion_linear: create convergent field
    float r_inv = 1.0 / (r_safe + 0.02);
    
    // Angular coordinate
    float theta = atan(uv.y, uv.x);
    
    // spiral_offset: logarithmic spiral with tightness
    float log_r = log(r_safe + 0.001);
    float arm_count = 5.0;
    float tightness = 2.2;
    
    // Decoupled time speeds for animation
    float t1 = iTime * 0.8;
    float t2 = iTime * 1.04;
    float t3 = iTime * 1.36;
    
    // Spiral phase with inversion_linear counter-rotation
    float spiral_phase = theta * arm_count / (2.0 * 3.14159) + log_r * tightness - t1 * 0.6;
    
    // sdf_analytic: compute signed distance to spiral arm
    float arm_width = 0.15;
    float spiral_wave = sin(spiral_phase * 6.28318) * 0.5 + 0.5;
    float spiral_sdf = abs(spiral_wave - 0.5) * 2.0;
    float arm_glow = exp(-spiral_sdf * 8.0);
    
    // Radial depth field with decoupled speed
    float radial_modulation = sin(log_r * 5.5 + t2 * 1.2) * 0.5 + 0.5;
    float radial_sdf = smoothstep(0.4, 0.0, abs(radial_modulation - 0.5));
    
    // Combine geometry layers
    float field_value = arm_glow * 0.7 + radial_sdf * 0.3;
    
    // Add convergent center pull
    float convergence_pull = exp(-r_inv * 0.3) * 0.8;
    field_value = mix(field_value, 1.0, convergence_pull * 0.4);
    
    // Layer 2: COLORIZATION - posterized_rainbow (EXACTLY as specified)
    float field_scaled = field_value;
    float scale = 3.5 + sin(t3 * 0.5) * 0.5;
    
    float hue_raw = fract(field_scaled * scale);
    float steps = 7.0;
    float cell = hue_raw * steps;
    float hue = (floor(cell) + smoothstep(0.0, 0.35, fract(cell))) / steps;
    
    vec3 col = hsv(hue, 1.0, 0.9);
    
    // Layer 3: SHAPING - sqrt_gamma for perceptually smooth falloff
    // Add depth illusion through nested modulation
    float depth_wave = sin(log_r * 7.2 - t1 * 0.8) * 0.5 + 0.5;
    float brightness_modulation = field_value * depth_wave;
    
    // sqrt_gamma correction
    brightness_modulation = sqrt(brightness_modulation);
    
    col *= brightness_modulation;
    
    // Secondary spiral at different phase for interference pattern
    float spiral_phase_2 = theta * arm_count / (2.0 * 3.14159) - log_r * tightness * 0.8 + t2 * 0.4;
    float spiral_wave_2 = sin(spiral_phase_2 * 6.28318) * 0.5 + 0.5;
    float spiral_sdf_2 = abs(spiral_wave_2 - 0.5) * 2.0;
    float arm_glow_2 = exp(-spiral_sdf_2 * 6.0);
    
    // Blend secondary for depth
    float hue_raw_2 = fract((1.0 - arm_glow_2) * scale * 1.3);
    float cell_2 = hue_raw_2 * steps;
    float hue_2 = (floor(cell_2) + smoothstep(0.0, 0.35, fract(cell_2))) / steps;
    vec3 col_2 = hsv(hue_2, 0.95, 0.85);
    
    col = mix(col, col_2, arm_glow_2 * 0.4);
    
    // Vanishing point glow
    float vanish_glow = exp(-r_inv * 0.15) * 0.5;
    col += vec3(0.3, 0.2, 0.5) * vanish_glow;
    
    // Feather edges to prevent hard cutoff
    float edge_fade = smoothstep(2.5, 0.5, r);
    col *= edge_fade;
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:5d1ff09b(convergent)", `// shader_id: 5d1ff09b48eb
// archetype: convergent
// colorization: posterized_rainbow
// techniques: log_shear, spiral_offset, sdf_analytic
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

vec3 hsv(float h, float s, float v) {
    float c = v * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = v - c;
    vec3 rgb;
    if (h < 1.0/6.0) rgb = vec3(c, x, 0.0);
    else if (h < 2.0/6.0) rgb = vec3(x, c, 0.0);
    else if (h < 3.0/6.0) rgb = vec3(0.0, c, x);
    else if (h < 4.0/6.0) rgb = vec3(0.0, x, c);
    else if (h < 5.0/6.0) rgb = vec3(x, 0.0, c);
    else rgb = vec3(c, 0.0, x);
    return rgb + m;
}

float sdf_spiral_arm(float theta, float log_r, float arm_width, float tightness) {
    float spiral_curve = log_r * tightness;
    float theta_normalized = mod(theta / (2.0 * 3.14159) * 4.0, 1.0);
    float angle_phase = spiral_curve / (2.0 * 3.14159);
    float dist = abs(mod(theta_normalized - angle_phase + 0.5, 1.0) - 0.5);
    return dist - arm_width;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    float epsilon = 0.02;
    float log_r = log(r + epsilon);
    
    float tightness = 2.2;
    float spiral_offset = log_r * tightness + iTime * 0.5;
    
    float arms = 4.0;
    float spiral_phase = theta + spiral_offset;
    float arm_angle = mod(spiral_phase / (2.0 * 3.14159) * arms, 1.0);
    
    float arm_width = 0.12;
    float arm_sdf = abs(mod(arm_angle + 0.5, 1.0) - 0.5) - arm_width;
    float arm_glow = exp(-abs(arm_sdf) * 4.0) * 0.8;
    
    float radial_depth = sin(log_r * 5.0 - iTime * 0.8) * 0.5 + 0.5;
    float angular_depth = sin(theta * 3.0 + iTime * 0.6) * 0.5 + 0.5;
    float time_depth = sin(iTime * 1.2) * 0.5 + 0.5;
    
    float composite = arm_glow * 0.6 + radial_depth * 0.25 + angular_depth * 0.15;
    
    float r_inv = 1.0 / (r + 0.05);
    float convergence_pull = exp(-r * 2.5) * 0.7;
    
    float field_value = composite + convergence_pull;
    field_value = mod(field_value, 1.0);
    
    float hue_raw = fract(field_value * 3.5);
    float steps = 7.0;
    float cell = hue_raw * steps;
    float hue = (floor(cell) + smoothstep(0.0, 0.35, fract(cell))) / steps;
    
    vec3 col = hsv(hue, 1.0, 0.9);
    
    float center_depth = 1.0 - smoothstep(0.0, 0.8, r);
    col = mix(col, vec3(1.0), center_depth * 0.3);
    
    float vignette = smoothstep(2.5, 0.3, r);
    col *= vignette;
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:5f87abaf(convergent)", `// shader_id: 5f87abaf4bec
// archetype: convergent
// colorization: iq_cosine_palette
// techniques: log_shear, sdf_analytic, spiral_offset
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // log_shear: logarithmic coordinate for self-similar depth
    float log_r = log(r + 0.001);
    
    // spiral_offset: wind arms into logarithmic spiral
    float arm_count = 5.0;
    float tightness = 2.2;
    float spiral_phase = theta + log_r * tightness;
    
    // sdf_analytic: signed distance to nearest spiral arm isoline
    float arm_period = 6.28318 / arm_count;
    float phase_mod = mod(spiral_phase, arm_period);
    float arm_distance = min(phase_mod, arm_period - phase_mod);
    float sdf = arm_distance - 0.4;
    
    // Create sharp glow edges from SDF
    float arm_glow = exp(-abs(sdf) * 8.0);
    
    // Radial inversion effect: pulls gaze toward center
    float r_inv = 1.0 / (r + 0.02);
    float depth_compression = smoothstep(3.0, 0.1, r_inv);
    
    // Decoupled time speeds for continuous non-resolving motion
    float angle_drift = sin(spiral_phase - iTime * 1.3) * 0.5 + 0.5;
    float radial_drift = sin(log_r * 6.0 + iTime * 0.8) * 0.5 + 0.5;
    float temporal_drift = sin(iTime * 0.5) * 0.5 + 0.5;
    
    // Composite field value for color mapping
    float field_value = mix(angle_drift, radial_drift, 0.6);
    field_value = mix(field_value, arm_glow, 0.4);
    field_value += depth_compression * 0.3;
    
    // Central convergence pull: exponential falloff from center
    float center_pull = exp(-r * 2.5) * 2.0;
    field_value += center_pull * 0.5;
    
    // Smooth wraparound for seamless looping
    field_value = fract(field_value + iTime * 0.25);
    
    // iq_cosine_palette: Inigo Quilez smooth perceptually uniform colorization
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    
    float drift = iTime * 0.15;
    vec3 col = a + b * cos(6.28318 * (c * (field_value + drift) + d));
    
    // Depth illusion: modulate brightness with log distance
    float depth_illusion = 1.0 - smoothstep(0.0, 4.0, log_r);
    col *= mix(0.4, 1.0, depth_illusion);
    
    // Enhance center glow for vanishing point effect
    col += vec3(0.2, 0.15, 0.25) * center_pull * 0.6;
    
    // Vignette for convergent attention pull
    float vignette = smoothstep(2.5, 0.0, r);
    col *= mix(0.3, 1.0, vignette);
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:e28902e3(convergent+rot)", `// shader_id: e28902e37bb8
// archetype: convergent
// colorization: iq_cosine_palette
// techniques: log_shear, sdf_analytic, spiral_offset
// variant_of: 5f87abaf4bec (added whole-field rotation)
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);

    // Rotate entire field
    float rot_angle = iTime * 0.15;
    float ca = cos(rot_angle), sa = sin(rot_angle);
    uv = vec2(uv.x * ca - uv.y * sa, uv.x * sa + uv.y * ca);

    float r = length(uv);
    float theta = atan(uv.y, uv.x);

    // log_shear: logarithmic coordinate for self-similar depth
    float log_r = log(r + 0.001);

    // spiral_offset: wind arms into logarithmic spiral
    float arm_count = 5.0;
    float tightness = 2.2;
    float spiral_phase = theta + log_r * tightness;

    // sdf_analytic: signed distance to nearest spiral arm isoline
    float arm_period = 6.28318 / arm_count;
    float phase_mod = mod(spiral_phase, arm_period);
    float arm_distance = min(phase_mod, arm_period - phase_mod);
    float sdf = arm_distance - 0.4;

    // Create sharp glow edges from SDF
    float arm_glow = exp(-abs(sdf) * 8.0);

    // Radial inversion effect: pulls gaze toward center
    float r_inv = 1.0 / (r + 0.02);
    float depth_compression = smoothstep(3.0, 0.1, r_inv);

    // Decoupled time speeds for continuous non-resolving motion
    float angle_drift = sin(spiral_phase - iTime * 1.3) * 0.5 + 0.5;
    float radial_drift = sin(log_r * 6.0 + iTime * 0.8) * 0.5 + 0.5;
    float temporal_drift = sin(iTime * 0.5) * 0.5 + 0.5;

    // Composite field value for color mapping
    float field_value = mix(angle_drift, radial_drift, 0.6);
    field_value = mix(field_value, arm_glow, 0.4);
    field_value += depth_compression * 0.3;

    // Central convergence pull: exponential falloff from center
    float center_pull = exp(-r * 2.5) * 2.0;
    field_value += center_pull * 0.5;

    // Smooth wraparound for seamless looping
    field_value = fract(field_value + iTime * 0.25);

    // iq_cosine_palette: Inigo Quilez smooth perceptually uniform colorization
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);

    float drift = iTime * 0.15;
    vec3 col = a + b * cos(6.28318 * (c * (field_value + drift) + d));

    // Depth illusion: modulate brightness with log distance
    float depth_illusion = 1.0 - smoothstep(0.0, 4.0, log_r);
    col *= mix(0.4, 1.0, depth_illusion);

    // Enhance center glow for vanishing point effect
    col += vec3(0.2, 0.15, 0.25) * center_pull * 0.6;

    // Vignette for convergent attention pull
    float vignette = smoothstep(2.5, 0.0, r);
    col *= mix(0.3, 1.0, vignette);

    fragColor = vec4(col, 1.0);
}`],
  ["rated:9270064e(convergent)", `// shader_id: 9270064e0ff5
// archetype: convergent
// colorization: posterized_rainbow
// techniques: inversion_linear, log_shear, spiral_offset, sdf_analytic
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

vec3 hsv(float h, float s, float v) {
    h = fract(h);
    float c = v * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = v - c;
    vec3 rgb;
    if (h < 1.0/6.0) rgb = vec3(c, x, 0.0);
    else if (h < 2.0/6.0) rgb = vec3(x, c, 0.0);
    else if (h < 3.0/6.0) rgb = vec3(0.0, c, x);
    else if (h < 4.0/6.0) rgb = vec3(0.0, x, c);
    else if (h < 5.0/6.0) rgb = vec3(x, 0.0, c);
    else rgb = vec3(c, 0.0, x);
    return rgb + m;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);

    float r = length(uv);
    float theta = atan(uv.y, uv.x);

    float eps = 0.02;
    float r_safe = max(r, eps);

    float log_r = log(r_safe);

    float arms = 5.0;
    float tightness = 2.2;

    float t1 = iTime * 0.4;
    float t2 = iTime * 0.52;
    float t3 = iTime * 0.68;

    float spiral_phase = theta + log_r * tightness + t1;

    float angle_oscillation = sin(spiral_phase * arms) * 0.5 + 0.5;

    float radial_wave1 = sin(log_r * 6.0 - t2 * 1.3) * 0.5 + 0.5;
    float radial_wave2 = sin(log_r * 9.0 - t3 * 1.7) * 0.5 + 0.5;

    float arm_pattern = sin(theta * arms + log_r * 3.5 + t1 * 0.8);
    float arm_contrib = smoothstep(-0.3, 0.7, arm_pattern) * 0.5 + 0.5;

    float field_value = angle_oscillation * 0.4 + radial_wave1 * 0.25 + arm_contrib * 0.35;

    float convergence = exp(-r * 2.5) * 0.8;
    field_value = field_value * (1.0 - convergence * 0.4) + convergence * 0.5;

    float spiral_arm_dist = abs(sin(theta * arms + log_r * tightness));
    float arm_glow = exp(-spiral_arm_dist * 8.0) * 0.6;

    field_value = mix(field_value, field_value + arm_glow * 0.3, 0.7);

    float hue_raw = fract(field_value * 3.5);
    float steps = 7.0;
    float cell = hue_raw * steps;
    float hue = (floor(cell) + smoothstep(0.0, 0.35, fract(cell))) / steps;

    vec3 col = hsv(hue, 1.0, 0.9);

    float brightness = field_value;
    brightness = sqrt(brightness);
    col *= brightness;

    float center_glow = exp(-r * 3.2) * 0.5;
    col += center_glow * vec3(0.3, 0.2, 0.5);

    float vignette = smoothstep(2.5, 0.5, r);
    col *= mix(vec3(0.4), vec3(1.0), vignette);

    col = mix(col, col * col, 0.15);

    fragColor = vec4(col, 1.0);
}`],
  ["rated:545a8dc3(sdf_outline)", `// shader_id: 545a8dc3d69f
// archetype: sdf_outline
// colorization: field_rainbow
// techniques: arm_count, sdf_analytic
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

vec3 hsv(float h, float s, float v) {
    float c = v * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = v - c;
    vec3 col = vec3(0.0);
    if(h < 0.16667) col = vec3(c, x, 0.0);
    else if(h < 0.33333) col = vec3(x, c, 0.0);
    else if(h < 0.5) col = vec3(0.0, c, x);
    else if(h < 0.66667) col = vec3(0.0, x, c);
    else if(h < 0.83333) col = vec3(x, 0.0, c);
    else col = vec3(c, 0.0, x);
    return col + m;
}

float sdSpiral(vec2 p, float arms, float tightness, float t) {
    float r = length(p);
    if(r < 0.001) r = 0.001;
    float theta = atan(p.y, p.x);
    float log_r = log(r);
    
    float phase = (theta / 6.28318530718 * arms + log_r * tightness - t);
    float isoline = abs(fract(phase + 0.5) - 0.5);
    
    return isoline * r * 0.5;
}

float triangleWave(float x) {
    return abs(fract(x) - 0.5) * 2.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float t = iTime * 0.4;
    float arm_count = 4.0;
    float tightness = 2.2;
    
    float d = sdSpiral(uv, arm_count, tightness, t);
    
    float glow = exp(-d * 25.0);
    float outline = smoothstep(0.02, 0.008, d);
    
    float brightness = glow + outline * 0.6;
    brightness = sqrt(brightness);
    
    float r = length(uv);
    float field_value = fract(r * 3.0 + log(r + 0.2) * 1.5 + t * 0.5);
    
    float tri_wave = triangleWave(field_value * 2.0);
    field_value = mix(field_value, tri_wave, 0.3);
    
    float hue = fract(field_value * 2.5 + iTime * 0.15);
    vec3 col = hsv(hue, 0.95, 0.88);
    
    float depth_factor = 1.0 / (1.0 + r * 0.8);
    brightness *= depth_factor;
    
    float pulsing = 0.9 + 0.1 * sin(iTime * 1.5 + r * 3.0);
    brightness *= pulsing;
    
    col *= brightness;
    col += vec3(0.05) * glow;
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:112b930a(kaleidoscopic)", `// shader_id: 112b930af900
// archetype: kaleidoscopic
// colorization: channel_offset
// techniques: spiral_offset
#define PI 3.14159265359
#define TAU 6.28318530718

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // Fract time precision wrapper for long sessions
    float time_wrapped = fract(iTime * 0.1) * 10.0;
    
    // N-fold kaleidoscope symmetry
    float N = 8.0;
    float sector = TAU / N;
    float t_folded = mod(theta, sector);
    if (t_folded > sector * 0.5) {
        t_folded = sector - t_folded;
    }
    
    // Decoupled rotation speeds for vortex effect
    float inner_speed = 0.15;
    float outer_speed = 0.35;
    float depth_mix = smoothstep(0.1, 1.2, r);
    float rot_angle = mix(inner_speed, outer_speed, depth_mix) * time_wrapped;
    
    // Spiral offset: logarithmic spiral winds the arms
    float tightness = 2.5;
    float spiral_phase = t_folded * N + log(max(r, 0.01)) * tightness + rot_angle;
    float spiral_field = sin(spiral_phase) * 0.5 + 0.5;
    
    // Convergent radial waves pull toward center
    float radial_wave = sin(r * 12.0 - time_wrapped * 0.8 + spiral_phase * 0.3);
    float wave_ring = abs(fract(r * 6.0 - time_wrapped * 0.25) - 0.5) * 2.0;
    
    // Triangle wave shaping for sharper depth perception
    float tri_wave = abs(fract(r * 8.0 + time_wrapped * 0.1) - 0.5) * 2.0;
    
    // Layer combination with depth modulation
    float base_field = spiral_field * 0.4 + wave_ring * 0.3 + radial_wave * 0.1 + tri_wave * 0.2;
    
    // Convergent focal point enhancement
    float focal_pull = 1.0 / (0.3 + r * r);
    float field_combined = base_field * (0.7 + focal_pull * 0.3);
    
    // Sqrt gamma correction for perceptually smooth falloff
    field_combined = sqrt(max(field_combined, 0.0));
    
    // Channel offset colorization (EXACTLY as specified)
    vec3 col = vec3(
        field_combined * (0.5 + 0.5 * sin(time_wrapped * 1.00 + spiral_phase)),
        field_combined * (0.5 + 0.5 * sin(time_wrapped * 1.00 + spiral_phase + 1.047)),
        field_combined * (0.5 + 0.5 * sin(time_wrapped * 1.00 + spiral_phase + 2.094))
    );
    
    // Chromatic aberration shimmer from phase offset
    float chroma_offset = 0.03 * sin(time_wrapped * 0.3 + r * 5.0);
    col.r += chroma_offset * 0.15;
    col.b -= chroma_offset * 0.1;
    
    // Outer vignette for infinite depth illusion
    float vignette = smoothstep(2.0, 0.0, r);
    col *= mix(0.3, 1.0, vignette);
    
    // Pulsing center for hypnotic draw
    float pulse = 0.5 + 0.5 * sin(time_wrapped * 0.6 + r * 3.0);
    col += vec3(0.1, 0.05, 0.15) * pulse / (0.5 + r * 2.0);
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:f3094d9f(sdf_outline)", `// shader_id: f3094d9feaaf
// archetype: sdf_outline
// colorization: field_rainbow
// techniques: spiral_offset, sdf_analytic
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;

vec3 hsv(float h, float s, float v) {
    h = fract(h);
    float c = v * s;
    float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
    float m = v - c;
    vec3 rgb;
    if (h < 0.1667) rgb = vec3(c, x, 0.0);
    else if (h < 0.3333) rgb = vec3(x, c, 0.0);
    else if (h < 0.5) rgb = vec3(0.0, c, x);
    else if (h < 0.6667) rgb = vec3(0.0, x, c);
    else if (h < 0.8333) rgb = vec3(x, 0.0, c);
    else rgb = vec3(c, 0.0, x);
    return rgb + m;
}

float sdSpiral(vec2 p, float arms, float tightness, float t) {
    float r = length(p);
    if (r < 0.001) return 0.0;
    
    float theta = atan(p.y, p.x);
    float log_r = log(r);
    
    float phase = (theta / (2.0 * 3.14159265) * arms + log_r * tightness - t);
    float frac = fract(phase + 0.5) - 0.5;
    float dist = abs(frac) * (2.0 / arms);
    
    return dist * r;
}

float sdNestedRings(vec2 p, float t) {
    float r = length(p);
    if (r < 0.001) return 1.0;
    
    float wave = sin(r * 12.0 - t * 2.5) * 0.5 + 0.5;
    float ring = abs(fract(r * 3.5 - t * 0.8) - 0.5);
    
    return ring * (0.3 + 0.7 * wave);
}

float sdRadialWave(vec2 p, float t) {
    float r = length(p);
    float theta = atan(p.y, p.x);
    
    float wave = sin(theta * 7.0 - t) * sin(r * 8.0 - t * 1.3);
    float radial = sin(r * 15.0 - t * 2.0) * 0.5 + 0.5;
    
    return fract(wave * radial + t * 0.3);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float t = iTime;
    
    float d1 = sdSpiral(uv, 5.0, 2.2, t * 0.4);
    float d2 = sdSpiral(uv * 0.6, 4.0, 1.8, t * 0.35);
    float d3 = sdNestedRings(uv, t);
    float d4 = sdRadialWave(uv, t);
    
    float glow1 = exp(-d1 * 25.0);
    float glow2 = exp(-d2 * 28.0);
    float glow3 = exp(-d3 * 18.0);
    float glow4 = exp(-d4 * 12.0);
    
    float outline1 = smoothstep(0.02, 0.008, d1);
    float outline2 = smoothstep(0.018, 0.007, d2);
    
    float field = glow1 * 0.4 + glow2 * 0.35 + glow3 * 0.15 + glow4 * 0.1;
    field += outline1 * 0.3 + outline2 * 0.2;
    
    float r = length(uv);
    float convergent = sin(r * 3.0 - t * 1.5) * exp(-r * 1.2);
    field += convergent * 0.15;
    
    float depth_layer = pow(1.0 / (1.0 + r * 0.8), 0.5);
    field = field * depth_layer;
    
    float hue = fract(field * 1.8 + t * 0.25);
    vec3 col = hsv(hue, 1.0, 0.85);
    
    float brightness = pow(field, 0.7);
    col = col * brightness;
    
    col += vec3(0.05 * sin(t * 0.3 + r * 5.0));
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:227cb7aa(kaleidoscopic)", `// shader_id: 227cb7aa6e34
// archetype: kaleidoscopic
// colorization: channel_offset
// techniques: spiral_offset
#define PI 3.14159265359
#define TAU 6.28318530718

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // fract_time_precision: wrap phase for long sessions
    float t = fract(iTime * 0.1) * 10.0;
    
    // arm_count: 8-fold kaleidoscopic symmetry
    float N = 8.0;
    float sector = TAU / N;
    float t_folded = mod(theta, sector);
    if (t_folded > sector * 0.5) t_folded = sector - t_folded;
    
    // Reconstruct folded UV
    vec2 uv_fold = r * vec2(cos(t_folded), sin(t_folded));
    
    // Depth illusion: logarithmic inversion creates infinite recession
    float depth = log(r + 0.1) * 0.5;
    
    // Convergent motion: pull toward center via modified radius
    float r_pull = r - depth * 0.3;
    r_pull = max(r_pull, 0.01);
    
    // spiral_offset: logarithmic spiral winds arms inward
    float spiral_phase = t_folded * N * 2.0 + log(r_pull + 0.1) * 2.5;
    
    // Decoupled rotation speeds create vortex without nausea
    float inner_rot = sin(t * 0.3) * PI;
    float outer_rot = cos(t * 0.5) * PI;
    float rot_mix = smoothstep(0.1, 0.7, r);
    float rotation = mix(inner_rot, outer_rot, rot_mix);
    
    // Main oscillating field
    float field = sin(spiral_phase + rotation + depth * 3.0) * 0.5 + 0.5;
    
    // triangle_wave: create animated ring pattern
    float ring_phase = fract(r * 4.0 - t * 0.25);
    float rings = abs(ring_phase - 0.5) * 2.0;
    
    // Combine field and rings
    float pattern = mix(field, rings, 0.35 + 0.2 * sin(t * 0.7));
    
    // Additional radial oscillation for motion
    float radial_osc = sin(r * 8.0 - t * 2.0) * 0.3 + 0.7;
    pattern *= radial_osc;
    
    // Spiral distortion layer
    float spiral_dist = sin(t_folded * 3.0 + t * 1.2) * 0.2;
    float dist_r = r + spiral_dist;
    dist_r = max(dist_r, 0.01);
    
    // Secondary field with different frequency
    float field2 = sin(dist_r * 6.0 + t * 0.8 + theta * 4.0) * 0.5 + 0.5;
    pattern = mix(pattern, field2, 0.25);
    
    // sqrt_gamma: perceptually smooth falloff and brightness
    pattern = sqrt(max(pattern, 0.0));
    
    // channel_offset: chromatic aberration via phase offset
    float r_base = pattern;
    
    // Construct field_func equivalent with channel offsets
    float field_r = sin(spiral_phase + rotation + depth * 3.0 + t * 1.0) * 0.5 + 0.5;
    float field_g = sin(spiral_phase + rotation + depth * 3.0 + t * 1.0 + 1.047) * 0.5 + 0.5;
    float field_b = sin(spiral_phase + rotation + depth * 3.0 + t * 1.0 + 2.094) * 0.5 + 0.5;
    
    // Apply sqrt_gamma to each channel
    field_r = sqrt(max(field_r, 0.0));
    field_g = sqrt(max(field_g, 0.0));
    field_b = sqrt(max(field_b, 0.0));
    
    // Blend with secondary patterns
    field_r = mix(field_r, field2, 0.2) * pattern;
    field_g = mix(field_g, field2 * 0.8, 0.2) * pattern;
    field_b = mix(field_b, field2 * 1.2, 0.2) * pattern;
    
    // Radial falloff for depth
    float vignette = exp(-r * r * 0.8);
    
    vec3 col = vec3(field_r, field_g, field_b) * vignette;
    
    // Smooth saturation shift over time
    float hue_shift = sin(t * 0.3) * 0.5 + 0.5;
    col += vec3(
        sin(hue_shift * PI) * 0.2,
        sin(hue_shift * PI + 2.094) * 0.2,
        sin(hue_shift * PI + 4.189) * 0.2
    ) * pattern;
    
    // Final contrast enhancement
    col = mix(col, col * col, 0.3);
    
    fragColor = vec4(col, 1.0);
}`],
  ["rated:e05c7373(kaleidoscopic)", `// shader_id: e05c7373ee55
// archetype: kaleidoscopic
// colorization: field_rainbow
// techniques: spiral_offset, sdf_analytic
#define PI 3.14159265359
#define TAU 6.28318530718

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    
    // Kaleidoscope N-fold symmetry
    float N = 8.0;
    float sector = TAU / N;
    
    // Fold theta into fundamental domain
    float t_folded = mod(theta, sector);
    if (t_folded > sector * 0.5) {
        t_folded = sector - t_folded;
    }
    
    // Decoupled speed multipliers for different radial zones
    float time_inner = iTime * 0.8;
    float time_mid = iTime * 1.3;
    float time_outer = iTime * 1.7;
    
    float blend_mid = smoothstep(0.1, 0.4, r);
    float blend_outer = smoothstep(0.4, 1.2, r);
    
    float anim_time = mix(time_inner, time_mid, blend_mid);
    anim_time = mix(anim_time, time_outer, blend_outer);
    
    // Spiral offset using logarithmic spiral
    float log_r = log(r + 0.5);
    float spiral_tight = 3.5;
    float spiral_phase = t_folded * N * 1.5 + log_r * spiral_tight + anim_time * 0.5;
    
    // Analytic SDF-like spiral field
    float spiral_field = sin(spiral_phase) * 0.5 + 0.5;
    spiral_field = pow(spiral_field, 0.8);
    
    // Radial wave structure with triangle wave
    float radial_wave = abs(fract(r * 8.0 + anim_time * 0.2) - 0.5) * 2.0;
    radial_wave = sqrt(radial_wave);
    
    // Angular resonance in folded sector
    float angular_freq = 4.0;
    float angular_wave = sin(t_folded * angular_freq * PI + anim_time * 0.3) * 0.5 + 0.5;
    
    // Converging field: pull toward center with logarithmic depth
    float depth_pull = exp(-r * 1.5) * (1.0 - r * 0.5);
    depth_pull = max(0.0, depth_pull);
    
    // Combine fields
    float field = spiral_field * 0.4 + radial_wave * 0.3 + angular_wave * 0.2;
    field = field + depth_pull * 0.1;
    
    // Apply sqrt gamma for smooth falloff
    field = sqrt(field);
    
    // Field_rainbow colorization - EXACTLY as specified
    float field_scale = 3.5;
    float drift = 0.15;
    float hue = fract(field * field_scale + iTime * drift);
    
    vec3 col = hsv2rgb(vec3(hue, 1.0, 0.85));
    
    // Enhance depth with radial vignette
    float vignette = exp(-r * r * 0.8);
    col *= vignette * 1.2;
    
    // Subtle glow from field extrema
    float glow = abs(sin(field * PI)) * 0.2;
    col += vec3(glow) * 0.15;
    
    // Ensure values stay in valid range
    col = clamp(col, 0.0, 1.0);
    
    fragColor = vec4(col, 1.0);
}`]
];

let currentIdx = 0;
let animId = null;
let gl, prog, uTime, uRes, uMouse;

const canvas = document.getElementById('c');

function initGL() {
  gl = canvas.getContext('webgl2', {preserveDrawingBuffer: true});
  if (!gl) { document.getElementById('error').textContent = 'WebGL2 not available'; return false; }
  return true;
}

function stripPreamble(src) {
  return src.split('\n').filter(l => {
    const t = l.trim();
    return !t.startsWith('#version') && !t.startsWith('precision ') &&
           !(t.startsWith('uniform ') && (t.includes('iResolution') || t.includes('iTime') || t.includes('iMouse')));
  }).join('\n');
}

function loadShader(idx) {
  if (animId) { cancelAnimationFrame(animId); animId = null; }

  const [name, rawSrc] = SHADERS[idx];
  currentIdx = idx;

  document.querySelectorAll('.nav-btn').forEach((b, i) => b.classList.toggle('active', i === idx));
  document.getElementById('info').textContent = `${idx+1}/${SHADERS.length}: ${name}`;
  document.getElementById('src-code').textContent = rawSrc;
  document.getElementById('error').textContent = '';


  if (!gl && !initGL()) return;

  const fragHeader = `#version 300 es\nprecision highp float;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec4 iMouse;\nout vec4 _fragColor;\n`;
  const fragFooter = `\nvoid main() { mainImage(_fragColor, gl_FragCoord.xy); }`;
  const cleaned = stripPreamble(rawSrc);
  const fragSrc = fragHeader + cleaned + fragFooter;

  const vertSrc = `#version 300 es\nin vec2 a_pos;\nvoid main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

  if (prog) gl.deleteProgram(prog);

  function compile(type, src) {
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      document.getElementById('error').textContent = 'Compile error: ' + gl.getShaderInfoLog(sh);
      return null;
    }
    return sh;
  }

  const vert = compile(gl.VERTEX_SHADER, vertSrc);
  const frag = compile(gl.FRAGMENT_SHADER, fragSrc);
  if (!vert || !frag) return;

  prog = gl.createProgram();
  gl.attachShader(prog, vert);
  gl.attachShader(prog, frag);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    document.getElementById('error').textContent = 'Link error: ' + gl.getProgramInfoLog(prog);
    return;
  }
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  uRes = gl.getUniformLocation(prog, 'iResolution');
  uTime = gl.getUniformLocation(prog, 'iTime');
  uMouse = gl.getUniformLocation(prog, 'iMouse');

  gl.uniform3f(uRes, canvas.width, canvas.height, 1.0);
  gl.uniform4f(uMouse, 0, 0, 0, 0);

  const startTime = performance.now();
  function frame() {
    const t = (performance.now() - startTime) / 1000.0;
    gl.uniform1f(uTime, t);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    animId = requestAnimationFrame(frame);
  }
  frame();
}

function prev() { loadShader((currentIdx - 1 + SHADERS.length) % SHADERS.length); }
function next() { loadShader((currentIdx + 1) % SHADERS.length); }

document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') prev();
  if (e.key === 'ArrowRight') next();
});

const nav = document.getElementById('nav');
SHADERS.forEach(([name], i) => {
  const btn = document.createElement('button');
  btn.className = 'nav-btn ' + (name.startsWith('seed:') ? 'seed' : 'rated');
  btn.textContent = name.replace('seed:','').replace('rated:','').substring(0, 16);
  btn.onclick = () => loadShader(i);
  nav.appendChild(btn);
});

initGL();
loadShader(0);
</script>
</body>
</html>