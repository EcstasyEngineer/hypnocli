<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GLSL Rater v2</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; height: 100vh; font-family: monospace; }
canvas { display: block; position: fixed; inset: 0; width: 100vw; height: 100vh; }

#hypothesis-bar {
  position: fixed; top: 0; left: 0; right: 0;
  padding: 8px 16px;
  background: rgba(0,0,0,0.85);
  color: #aad; font: 13px monospace;
  z-index: 10; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

#panel {
  position: fixed; right: 0; top: 36px; bottom: 0;
  width: 260px;
  background: rgba(0,0,0,0.88);
  display: flex; flex-direction: column;
  padding: 12px;
  gap: 10px;
  z-index: 10;
  overflow-y: auto;
}

/* ── Gradient bar ── */
#score-section { display: flex; align-items: stretch; gap: 8px; }

#gradient-bar {
  width: 40px; height: 200px;
  border: 1px solid #444; border-radius: 4px;
  position: relative; cursor: pointer;
  flex-shrink: 0;
}
#gradient-bar canvas { width: 100%; height: 100%; border-radius: 3px; }
#gradient-handle {
  position: absolute; left: -4px; right: -4px;
  height: 4px; background: #fff; border-radius: 2px;
  pointer-events: none;
  box-shadow: 0 0 6px rgba(255,255,255,0.6);
}
#score-readout {
  font: bold 28px monospace; color: #fff;
  display: flex; align-items: center; justify-content: center;
  flex: 1;
}

/* ── Questions ── */
#questions { display: flex; flex-direction: column; gap: 6px; }
.question-row {
  display: flex; align-items: center; gap: 6px;
  font: 12px monospace; color: #ccc;
}
.question-row .q-text { flex: 1; }
.q-btn {
  width: 32px; height: 24px; border: 1px solid #555; border-radius: 3px;
  background: rgba(255,255,255,0.05); color: #888;
  font: 11px monospace; cursor: pointer;
  transition: all 0.1s;
}
.q-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
.q-btn.yes-active { background: rgba(80,200,80,0.4); color: #6f6; border-color: #6a6; }
.q-btn.no-active { background: rgba(200,80,80,0.4); color: #f66; border-color: #a66; }
.q-btn.focused { outline: 2px solid #88f; outline-offset: 1px; }

/* ── Defects ── */
#defects { display: flex; flex-wrap: wrap; gap: 4px; }
.defect-btn {
  padding: 3px 8px; border: 1px solid #555; border-radius: 3px;
  background: rgba(255,255,255,0.05); color: #888;
  font: 11px monospace; cursor: pointer;
  transition: all 0.1s;
}
.defect-btn:hover { background: rgba(255,200,80,0.15); color: #fc8; }
.defect-btn.active { background: rgba(255,120,40,0.4); color: #fa6; border-color: #a64; }

/* ── Note + submit ── */
#note {
  width: 100%;
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 4px;
  color: #ddd; font: 12px monospace;
  padding: 6px 8px; outline: none; resize: none;
  height: 48px;
}
#note:focus { border-color: rgba(255,255,255,0.35); background: rgba(255,255,255,0.1); }
#note::placeholder { color: #555; }

#submit-btn {
  width: 100%; height: 36px;
  border: 1px solid rgba(100,200,100,0.4); border-radius: 4px;
  background: rgba(100,200,100,0.15); color: #8c8;
  font: 14px monospace; cursor: pointer;
  transition: all 0.1s;
}
#submit-btn:hover { background: rgba(100,200,100,0.35); color: #afa; }

#discard-btn {
  width: 100%; height: 28px;
  border: 1px solid rgba(255,80,80,0.3); border-radius: 4px;
  background: rgba(255,80,80,0.06); color: #844;
  font: 12px monospace; cursor: pointer;
}
#discard-btn:hover { background: rgba(255,80,80,0.25); color: #f88; }

#info { position: fixed; top: 40px; left: 10px; color: #444; font: 11px monospace; z-index: 10; pointer-events: none; }

#waiting {
  position: fixed; inset: 0; z-index: 20;
  display: flex; align-items: center; justify-content: center;
  color: #333; font: 14px monospace;
  background: #000;
}

#flash {
  position: fixed; inset: 0; z-index: 30;
  background: rgba(0,0,0,0); pointer-events: none;
  transition: background 0.15s;
}

.section-label { font: 10px monospace; color: #555; text-transform: uppercase; letter-spacing: 1px; }
</style>
</head>
<body>
<div id="waiting">waiting for shader...</div>
<div id="flash"></div>
<div id="hypothesis-bar">—</div>
<canvas id="c"></canvas>
<div id="info">—</div>

<div id="panel">
  <div class="section-label">score</div>
  <div id="score-section">
    <div id="gradient-bar">
      <canvas id="grad-canvas" width="40" height="200"></canvas>
      <div id="gradient-handle" style="bottom: 50%"></div>
    </div>
    <div id="score-readout">0.50</div>
  </div>

  <div class="section-label">questions</div>
  <div id="questions"></div>

  <div class="section-label">defects</div>
  <div id="defects"></div>

  <textarea id="note" placeholder="optional note"></textarea>
  <button id="submit-btn">SUBMIT (Enter)</button>
  <button id="discard-btn">Discard (X)</button>
</div>

<script>
const PORT = location.port;
let prog = null, gl = null;
let startTime = null, frames = 0, fpsTs = 0;
let currentShaderId = null;
let rated = false;
let score = 0.50;
let answers = {};
let activeDefects = new Set();
let questionKeys = [];
let focusedQ = 0;

// ── Gradient bar ─────────────────────────────────────────────────────────────
const gradBar = document.getElementById('gradient-bar');
const gradCanvas = document.getElementById('grad-canvas');
const gradHandle = document.getElementById('gradient-handle');
const scoreReadout = document.getElementById('score-readout');

(function drawGradient() {
  const ctx = gradCanvas.getContext('2d');
  const g = ctx.createLinearGradient(0, 200, 0, 0);
  g.addColorStop(0, '#661111');
  g.addColorStop(0.3, '#995522');
  g.addColorStop(0.5, '#888833');
  g.addColorStop(0.7, '#448833');
  g.addColorStop(1, '#228844');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, 40, 200);
})();

function setScore(v) {
  score = Math.max(0, Math.min(1, v));
  score = Math.round(score * 20) / 20; // snap to 0.05
  gradHandle.style.bottom = (score * 100) + '%';
  scoreReadout.textContent = score.toFixed(2);
}

gradBar.addEventListener('mousedown', e => {
  function update(ev) {
    const rect = gradBar.getBoundingClientRect();
    const pct = 1 - (ev.clientY - rect.top) / rect.height;
    setScore(pct);
  }
  update(e);
  const move = ev => update(ev);
  const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', up);
});

// ── Questions ────────────────────────────────────────────────────────────────
function renderQuestions(questions) {
  const container = document.getElementById('questions');
  container.innerHTML = '';
  questionKeys = [];
  answers = {};
  focusedQ = 0;

  questions.forEach((q, i) => {
    const key = `q${i}`;
    questionKeys.push(key);
    answers[key] = null;

    const row = document.createElement('div');
    row.className = 'question-row';
    row.innerHTML = `
      <span class="q-text">${q}</span>
      <button class="q-btn q-yes" data-key="${key}">Y</button>
      <button class="q-btn q-no" data-key="${key}">N</button>
    `;
    container.appendChild(row);

    row.querySelector('.q-yes').addEventListener('click', () => toggleAnswer(key, true));
    row.querySelector('.q-no').addEventListener('click', () => toggleAnswer(key, false));
  });

  updateQuestionFocus();
}

function toggleAnswer(key, val) {
  answers[key] = answers[key] === val ? null : val;
  updateQuestionUI();
}

function updateQuestionUI() {
  document.querySelectorAll('.q-btn').forEach(btn => {
    const key = btn.dataset.key;
    const isYes = btn.classList.contains('q-yes');
    btn.classList.remove('yes-active', 'no-active');
    if (answers[key] === true && isYes) btn.classList.add('yes-active');
    if (answers[key] === false && !isYes) btn.classList.add('no-active');
  });
  updateQuestionFocus();
}

function updateQuestionFocus() {
  document.querySelectorAll('.q-btn').forEach(btn => btn.classList.remove('focused'));
  if (focusedQ < questionKeys.length) {
    const key = questionKeys[focusedQ];
    document.querySelectorAll(`.q-btn[data-key="${key}"]`).forEach(b => b.classList.add('focused'));
  }
}

// ── Defects ──────────────────────────────────────────────────────────────────
function renderDefects(defectTypes) {
  const container = document.getElementById('defects');
  container.innerHTML = '';
  activeDefects = new Set();

  Object.entries(defectTypes).forEach(([key, dt]) => {
    const btn = document.createElement('button');
    btn.className = 'defect-btn';
    btn.textContent = dt.label;
    btn.title = dt.description;
    btn.dataset.key = key;
    btn.addEventListener('click', () => {
      if (activeDefects.has(key)) {
        activeDefects.delete(key);
        btn.classList.remove('active');
      } else {
        activeDefects.add(key);
        btn.classList.add('active');
      }
    });
    container.appendChild(btn);
  });
}

// ── WebGL setup ──────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
function resize() { canvas.width = window.innerWidth - 260; canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

gl = canvas.getContext('webgl2', {antialias: true});

const VERT = `#version 300 es\nin vec2 p;\nvoid main(){gl_Position=vec4(p,0,1);}`;
const FRAG_HEADER = `#version 300 es\nprecision highp float;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec4 iMouse;\nout vec4 _fc;\n`;
const FRAG_MAIN = `\nvoid main(){mainImage(_fc,gl_FragCoord.xy);}`;

const vBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,-1,1,1,-1,1]), gl.STATIC_DRAW);

let uRes, uTime, uMouse;

function stripPreamble(src) {
  return src.split('\n').filter(l => {
    const s = l.trim();
    return !s.startsWith('#version') && !s.startsWith('precision ')
        && !s.startsWith('uniform vec3 iResolution') && !s.startsWith('uniform float iTime')
        && !s.startsWith('uniform vec4 iMouse') && !s.startsWith('out vec4 fragColor');
  }).join('\n');
}

function compile(type, src) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    console.error('Compile error:', gl.getShaderInfoLog(sh));
    return null;
  }
  return sh;
}

function loadShader(shaderId, glslSrc) {
  const clean = stripPreamble(glslSrc);
  const vert = compile(gl.VERTEX_SHADER, VERT);
  const frag = compile(gl.FRAGMENT_SHADER, FRAG_HEADER + clean + FRAG_MAIN);
  if (!vert || !frag) {
    document.getElementById('info').textContent = shaderId + ' — COMPILE ERROR';
    return false;
  }
  const newProg = gl.createProgram();
  gl.attachShader(newProg, vert); gl.attachShader(newProg, frag);
  gl.linkProgram(newProg);
  if (!gl.getProgramParameter(newProg, gl.LINK_STATUS)) {
    console.error('Link error:', gl.getProgramInfoLog(newProg));
    return false;
  }
  if (prog) gl.deleteProgram(prog);
  prog = newProg;
  gl.useProgram(prog);
  const loc = gl.getAttribLocation(prog, 'p');
  gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  uRes = gl.getUniformLocation(prog, 'iResolution');
  uTime = gl.getUniformLocation(prog, 'iTime');
  uMouse = gl.getUniformLocation(prog, 'iMouse');
  gl.uniform4f(uMouse, 0, 0, 0, 0);

  currentShaderId = shaderId;
  startTime = null; rated = false;
  setScore(0.50);
  document.getElementById('info').textContent = shaderId;
  document.getElementById('note').value = '';
  document.getElementById('note').blur();
  document.title = shaderId;

  const flash = document.getElementById('flash');
  flash.style.background = 'rgba(0,0,0,0.7)';
  setTimeout(() => { flash.style.background = 'rgba(0,0,0,0)'; }, 200);
  document.getElementById('waiting').style.display = 'none';
  return true;
}

canvas.addEventListener('mousemove', e => {
  if (uMouse) gl.uniform4f(uMouse, e.clientX, canvas.height - e.clientY, 0, 0);
});

// ── Render loop ──────────────────────────────────────────────────────────────
function frame(ts) {
  requestAnimationFrame(frame);
  if (!prog) return;
  if (!startTime) { startTime = ts; fpsTs = ts; }
  const t = (ts - startTime) / 1000;
  gl.uniform1f(uTime, t);
  gl.uniform3f(uRes, canvas.width, canvas.height, 1);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  frames++;
  if (ts - fpsTs > 1000) {
    document.getElementById('info').textContent = (currentShaderId || '—') + '  ' + frames + ' fps';
    frames = 0; fpsTs = ts;
  }
}
requestAnimationFrame(frame);

// ── SSE ──────────────────────────────────────────────────────────────────────
function connect() {
  const es = new EventSource('/events');
  es.onmessage = e => {
    const data = JSON.parse(e.data);
    const { shader_id, glsl, hypothesis, questions, defect_types } = data;
    if (loadShader(shader_id, glsl)) {
      document.getElementById('hypothesis-bar').textContent = hypothesis || '—';
      renderQuestions(questions || []);
      renderDefects(defect_types || {});
    }
  };
  es.onerror = () => {
    document.getElementById('info').textContent = 'reconnecting...';
    es.close();
    setTimeout(connect, 2000);
  };
}
connect();

// ── Submit ───────────────────────────────────────────────────────────────────
async function submit(discard) {
  if (rated || !currentShaderId) return;
  rated = true;
  const note = document.getElementById('note').value.trim();
  document.getElementById('waiting').style.display = 'flex';
  document.getElementById('waiting').textContent = 'rated — next shader incoming...';
  const payload = {
    shader_id: currentShaderId,
    score: discard ? 0 : score,
    answers: discard ? {} : answers,
    defects: [...activeDefects],
    note: note,
    discard: !!discard,
  };
  await fetch('/rate', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(payload),
  }).catch(() => {});
}

document.getElementById('submit-btn').addEventListener('click', () => submit(false));
document.getElementById('discard-btn').addEventListener('click', () => submit(true));

// ── Keyboard ─────────────────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (e.target === document.getElementById('note')) return;
  if (rated) return;

  if (e.key === 'ArrowUp') { e.preventDefault(); setScore(score + 0.05); }
  else if (e.key === 'ArrowDown') { e.preventDefault(); setScore(score - 0.05); }
  else if (e.key === 'y' || e.key === 'Y') {
    if (focusedQ < questionKeys.length) {
      toggleAnswer(questionKeys[focusedQ], true);
    }
  }
  else if (e.key === 'n' || e.key === 'N') {
    if (focusedQ < questionKeys.length) {
      toggleAnswer(questionKeys[focusedQ], false);
    }
  }
  else if (e.key === 'Tab') {
    e.preventDefault();
    focusedQ = (focusedQ + 1) % Math.max(questionKeys.length, 1);
    updateQuestionFocus();
  }
  else if (e.key === 'Enter') { submit(false); }
  else if (e.key === 'x' || e.key === 'X') { submit(true); }
});
</script>
</body>
</html>
